use std::{sync::Arc, time::Duration};

use anyhow::Result;
use axum::extract::ws::{Message, WebSocket};
use axum::{
    extract::{State, WebSocketUpgrade},
    http::{header::CONTENT_TYPE, StatusCode},
    response::{IntoResponse, Response},
    routing::get,
    Json, Router,
};
use chrono::Utc;
use futures_util::StreamExt;
use prometheus::{opts, Encoder, Gauge, IntGauge, IntGaugeVec, Registry, TextEncoder};
use serde::{Deserialize, Serialize};
use tokio::{sync::RwLock, task::JoinHandle, time::interval};
use tokio_stream::wrappers::IntervalStream;
use tower_http::cors::{Any, CorsLayer};
use tracing::{error, info, warn};

#[derive(Clone)]
struct AppState {
    stats: Arc<RwLock<StatsSnapshot>>,
    client: reqwest::Client,
    metrics: Metrics,
    config: Arc<ServiceConfig>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct ServiceConfig {
    service_name: String,
    bind_addr: String,
    port_manager_url: String,
    axon_url: String,
    legion_url: String,
    slotgraph_url: String,
    wazuh_url: String,
    sledis_url: String,
}

impl ServiceConfig {
    fn from_env() -> Self {
        Self {
            service_name: std::env::var("SERVICE_NAME")
                .unwrap_or_else(|_| "ctas7-cdn-statistical".to_string()),
            bind_addr: std::env::var("BIND_ADDR").unwrap_or_else(|_| "0.0.0.0:18108".to_string()),
            port_manager_url: std::env::var("PORT_MANAGER_URL")
                .unwrap_or_else(|_| "http://localhost:18103".to_string()),
            axon_url: std::env::var("AXON_URL")
                .unwrap_or_else(|_| "http://localhost:15176".to_string()),
            legion_url: std::env::var("LEGION_URL")
                .unwrap_or_else(|_| "http://localhost:15177".to_string()),
            slotgraph_url: std::env::var("SLOTGRAPH_URL")
                .unwrap_or_else(|_| "http://localhost:18410".to_string()),
            wazuh_url: std::env::var("WAZUH_URL")
                .unwrap_or_else(|_| "http://localhost:55000".to_string()),
            sledis_url: std::env::var("SLEDIS_URL")
                .unwrap_or_else(|_| "http://localhost:19014".to_string()),
        }
    }
}

#[derive(Clone)]
struct Metrics {
    registry: Registry,
    threats_total: IntGauge,
    threats_critical: IntGauge,
    threats_high: IntGauge,
    events_per_sec: Gauge,
    tools_executed: IntGauge,
    entities_tracked: IntGauge,
    hd4_phase: IntGaugeVec,
    usims_generated: IntGauge,
}

impl Metrics {
    fn new() -> Self {
        let registry = Registry::new();

        macro_rules! register_gauge {
            ($metric:expr) => {{
                registry
                    .register(Box::new($metric.clone()))
                    .expect("register metric");
            }};
        }

        let threats_total = IntGauge::with_opts(opts!(
            "ctas7_threats_total",
            "Total number of active threats tracked by AXON"
        ))
        .expect("metric");
        register_gauge!(threats_total);

        let threats_critical =
            IntGauge::with_opts(opts!("ctas7_threats_critical", "Critical severity threats"))
                .expect("metric");
        register_gauge!(threats_critical);

        let threats_high =
            IntGauge::with_opts(opts!("ctas7_threats_high", "High severity threats"))
                .expect("metric");
        register_gauge!(threats_high);

        let events_per_sec =
            Gauge::with_opts(opts!("ctas7_events_per_second", "Event ingestion rate"))
                .expect("metric");
        register_gauge!(events_per_sec);

        let tools_executed = IntGauge::with_opts(opts!(
            "ctas7_tools_executed_total",
            "Tools executed across CTAS stack"
        ))
        .expect("metric");
        register_gauge!(tools_executed);

        let entities_tracked = IntGauge::with_opts(opts!(
            "ctas7_entities_tracked_total",
            "Entities tracked within Legion ECS"
        ))
        .expect("metric");
        register_gauge!(entities_tracked);

        let hd4_phase = IntGaugeVec::new(
            opts!("ctas7_hd4_phase_counts", "Counts per HD4 operational phase"),
            &["phase"],
        )
        .expect("metric");
        register_gauge!(hd4_phase);

        let usims_generated = IntGauge::with_opts(opts!(
            "ctas7_usims_generated_total",
            "USIMs generated by AXON"
        ))
        .expect("metric");
        register_gauge!(usims_generated);

        Self {
            registry,
            threats_total,
            threats_critical,
            threats_high,
            events_per_sec,
            tools_executed,
            entities_tracked,
            hd4_phase,
            usims_generated,
        }
    }

    fn update(&self, snapshot: &StatsSnapshot) {
        self.threats_total.set(snapshot.threats.total as i64);
        self.threats_critical.set(snapshot.threats.critical as i64);
        self.threats_high.set(snapshot.threats.high as i64);
        self.events_per_sec.set(snapshot.events.per_second);
        self.tools_executed.set(snapshot.tools.total_runs as i64);
        self.entities_tracked
            .set(snapshot.entities.total_entities as i64);
        self.usims_generated.set(snapshot.usims_generated as i64);

        let phases = [
            ("hunt", snapshot.hd4.hunt),
            ("detect", snapshot.hd4.detect),
            ("disrupt", snapshot.hd4.disrupt),
            ("disable", snapshot.hd4.disable),
            ("dominate", snapshot.hd4.dominate),
        ];

        for (phase, value) in phases {
            self.hd4_phase.with_label_values(&[phase]).set(value as i64);
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
struct StatsSnapshot {
    threats: ThreatStats,
    tools: ToolStats,
    entities: EntityStats,
    events: EventStats,
    hd4: Hd4Stats,
    usims_generated: u64,
    last_updated: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
struct ThreatStats {
    total: u64,
    critical: u64,
    high: u64,
    medium: u64,
    low: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
struct ToolStats {
    total_runs: u64,
    unique_tools: u64,
    average_runtime_ms: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
struct EntityStats {
    total_entities: u64,
    threats: u64,
    assets: u64,
    actors: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
struct EventStats {
    per_second: f64,
    last_minute: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
struct Hd4Stats {
    hunt: u64,
    detect: u64,
    disrupt: u64,
    disable: u64,
    dominate: u64,
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env().add_directive("info".parse()?),
        )
        .init();

    let config = Arc::new(ServiceConfig::from_env());
    let stats = Arc::new(RwLock::new(StatsSnapshot {
        last_updated: Utc::now().to_rfc3339(),
        ..Default::default()
    }));
    let metrics = Metrics::new();
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(8))
        .build()?;

    let state = AppState {
        stats: stats.clone(),
        client: client.clone(),
        metrics: metrics.clone(),
        config: config.clone(),
    };

    register_with_port_manager(&state).await?;

    // Spawn tasks
    let heartbeat_handle = spawn_heartbeat(state.clone());
    let collector_handle = spawn_collector(state.clone());

    let app = Router::new()
        .route("/health", get(health))
        .route("/metrics", get(metrics_handler))
        .route("/api/stats/threats", get(threat_stats_handler))
        .route("/api/stats/tools", get(tool_stats_handler))
        .route("/api/stats/entities", get(entity_stats_handler))
        .route("/api/stats/events", get(event_stats_handler))
        .route("/api/stats/summary", get(summary_handler))
        .route("/stream/stats", get(stream_stats))
        .with_state(state.clone())
        .layer(
            CorsLayer::new()
                .allow_headers(Any)
                .allow_methods(Any)
                .allow_origin(Any),
        );

    info!(
        "ðŸš€ CTAS-7 Statistical Analysis CDN v7.3.1 listening on {}",
        config.bind_addr
    );

    let listener = tokio::net::TcpListener::bind(&config.bind_addr).await?;
    axum::serve(listener, app).await?;

    heartbeat_handle.abort();
    collector_handle.abort();

    Ok(())
}

fn spawn_heartbeat(state: AppState) -> JoinHandle<()> {
    tokio::spawn(async move {
        let mut ticker = interval(Duration::from_secs(30));
        loop {
            ticker.tick().await;
            if let Err(err) = send_heartbeat(&state).await {
                warn!("âš ï¸ heartbeat failed: {err}");
            }
        }
    })
}

fn spawn_collector(state: AppState) -> JoinHandle<()> {
    tokio::spawn(async move {
        let mut ticker = interval(Duration::from_secs(5));
        loop {
            ticker.tick().await;
            if let Err(err) = collect_stats(&state).await {
                warn!("âš ï¸ stats collector error: {err}");
            }
        }
    })
}

async fn register_with_port_manager(state: &AppState) -> Result<()> {
    let url = format!("{}/api/ports/register", state.config.port_manager_url);
    let payload = serde_json::json!({
        "service_name": state.config.service_name,
        "port": state
            .config
            .bind_addr
            .split(':')
            .next_back()
            .unwrap_or("18108")
            .parse::<u16>()
            .unwrap_or(18108),
        "protocol": "http",
        "health_endpoint": "/health",
        "metrics_endpoint": "/metrics",
        "role": "cdn"
    });

    state.client.post(url).json(&payload).send().await?;
    info!("âœ… Registered statistical CDN with port manager");
    Ok(())
}

async fn send_heartbeat(state: &AppState) -> Result<()> {
    let url = format!("{}/api/ports/heartbeat", state.config.port_manager_url);
    let snapshot = state.stats.read().await.clone();
    let payload = serde_json::json!({
        "service_name": state.config.service_name,
        "status": "healthy",
        "metrics": {
            "threats_total": snapshot.threats.total,
            "events_per_sec": snapshot.events.per_second,
            "tools_executed": snapshot.tools.total_runs,
            "entities": snapshot.entities.total_entities
        }
    });

    state.client.post(url).json(&payload).send().await?;
    Ok(())
}

async fn collect_stats(state: &AppState) -> Result<()> {
    let fallback_snapshot = state.stats.read().await.clone();
    let mut updated = StatsSnapshot {
        last_updated: Utc::now().to_rfc3339(),
        ..Default::default()
    };

    if let Some(axon_metrics) = fetch_json(
        &state.client,
        format!("{}/api/metrics", state.config.axon_url),
    )
    .await
    {
        merge_threat_metrics(&mut updated, &axon_metrics);
        merge_tool_metrics(&mut updated, &axon_metrics);
        updated.usims_generated = axon_metrics
            .get("usims_generated")
            .and_then(|v| v.as_u64())
            .unwrap_or(updated.usims_generated);
    }

    if let Some(legion_entities) = fetch_json(
        &state.client,
        format!("{}/api/entities/summary", state.config.legion_url),
    )
    .await
    {
        merge_entity_metrics(&mut updated, &legion_entities);
    }

    if let Some(wazuh_stats) = fetch_json(
        &state.client,
        format!("{}/api/events/statistics", state.config.wazuh_url),
    )
    .await
    {
        merge_event_metrics(&mut updated, &wazuh_stats);
    }

    if updated.threats.total == 0 {
        // Provide graceful degradation when upstream services are offline
        updated = fallback_snapshot;
    }

    state.metrics.update(&updated);
    *state.stats.write().await = updated;

    Ok(())
}

async fn fetch_json(client: &reqwest::Client, url: String) -> Option<serde_json::Value> {
    match client.get(url).send().await {
        Ok(resp) if resp.status().is_success() => resp.json().await.ok(),
        Ok(resp) => {
            warn!("Upstream responded with status {}", resp.status());
            None
        }
        Err(err) => {
            warn!("Failed to reach upstream: {err}");
            None
        }
    }
}

fn merge_threat_metrics(snapshot: &mut StatsSnapshot, data: &serde_json::Value) {
    if let Some(threats) = data.get("threats") {
        snapshot.threats.total = threats
            .get("total")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.threats.total);
        snapshot.threats.critical = threats
            .get("critical")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.threats.critical);
        snapshot.threats.high = threats
            .get("high")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.threats.high);
        snapshot.threats.medium = threats
            .get("medium")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.threats.medium);
        snapshot.threats.low = threats
            .get("low")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.threats.low);
    }

    if let Some(hd4) = data.get("hd4") {
        snapshot.hd4.hunt = hd4
            .get("hunt")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.hd4.hunt);
        snapshot.hd4.detect = hd4
            .get("detect")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.hd4.detect);
        snapshot.hd4.disrupt = hd4
            .get("disrupt")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.hd4.disrupt);
        snapshot.hd4.disable = hd4
            .get("disable")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.hd4.disable);
        snapshot.hd4.dominate = hd4
            .get("dominate")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.hd4.dominate);
    }
}

fn merge_tool_metrics(snapshot: &mut StatsSnapshot, data: &serde_json::Value) {
    if let Some(tools) = data.get("tools") {
        snapshot.tools.total_runs = tools
            .get("executed")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.tools.total_runs);
        snapshot.tools.unique_tools = tools
            .get("unique")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.tools.unique_tools);
        snapshot.tools.average_runtime_ms = tools
            .get("avg_runtime_ms")
            .and_then(|v| v.as_f64())
            .unwrap_or(snapshot.tools.average_runtime_ms);
    }
}

fn merge_entity_metrics(snapshot: &mut StatsSnapshot, data: &serde_json::Value) {
    snapshot.entities.total_entities = data
        .get("total")
        .and_then(|v| v.as_u64())
        .unwrap_or(snapshot.entities.total_entities);
    snapshot.entities.threats = data
        .get("threats")
        .and_then(|v| v.as_u64())
        .unwrap_or(snapshot.entities.threats);
    snapshot.entities.assets = data
        .get("assets")
        .and_then(|v| v.as_u64())
        .unwrap_or(snapshot.entities.assets);
    snapshot.entities.actors = data
        .get("actors")
        .and_then(|v| v.as_u64())
        .unwrap_or(snapshot.entities.actors);
}

fn merge_event_metrics(snapshot: &mut StatsSnapshot, data: &serde_json::Value) {
    if let Some(events) = data.get("events") {
        snapshot.events.per_second = events
            .get("per_second")
            .and_then(|v| v.as_f64())
            .unwrap_or(snapshot.events.per_second);
        snapshot.events.last_minute = events
            .get("last_minute")
            .and_then(|v| v.as_u64())
            .unwrap_or(snapshot.events.last_minute);
    }
}

async fn health(State(state): State<AppState>) -> impl IntoResponse {
    let stats = state.stats.read().await;
    Json(serde_json::json!({
        "status": "ok",
        "service": state.config.service_name,
        "last_updated": stats.last_updated,
        "threats": stats.threats.total,
        "events_per_sec": stats.events.per_second,
    }))
}

async fn metrics_handler(State(state): State<AppState>) -> impl IntoResponse {
    let metric_families = state.metrics.registry.gather();
    let mut buffer = Vec::new();
    let encoder = TextEncoder::new();
    if let Err(err) = encoder.encode(&metric_families, &mut buffer) {
        error!("Failed to encode metrics: {err}");
        return StatusCode::INTERNAL_SERVER_ERROR.into_response();
    }

    Response::builder()
        .status(StatusCode::OK)
        .header(CONTENT_TYPE, encoder.format_type())
        .body(axum::body::Body::from(buffer))
        .unwrap()
}

async fn threat_stats_handler(State(state): State<AppState>) -> Json<ThreatStats> {
    Json(state.stats.read().await.threats.clone())
}

async fn tool_stats_handler(State(state): State<AppState>) -> Json<ToolStats> {
    Json(state.stats.read().await.tools.clone())
}

async fn entity_stats_handler(State(state): State<AppState>) -> Json<EntityStats> {
    Json(state.stats.read().await.entities.clone())
}

async fn event_stats_handler(State(state): State<AppState>) -> Json<EventStats> {
    Json(state.stats.read().await.events.clone())
}

async fn summary_handler(State(state): State<AppState>) -> Json<StatsSnapshot> {
    Json(state.stats.read().await.clone())
}

async fn stream_stats(State(state): State<AppState>, ws: WebSocketUpgrade) -> impl IntoResponse {
    ws.on_upgrade(move |socket| handle_ws(socket, state))
}

async fn handle_ws(mut socket: WebSocket, state: AppState) {
    let mut interval = IntervalStream::new(interval(Duration::from_secs(2)));
    while interval.next().await.is_some() {
        let payload = {
            let stats = state.stats.read().await;
            serde_json::to_string(&*stats).unwrap_or_else(|_| "{}".to_string())
        };

        if socket.send(Message::Text(payload)).await.is_err() {
            break;
        }
    }
}
