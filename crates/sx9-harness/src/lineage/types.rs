//! Git Lineage Types
//!
//! Types for tracking behavioral declarations across Git history.
//!
//! CLSGS Annex A.4: Git carries semantic history. N-V-N-N annotations
//! function as semantic lineage markers that persist across Git operations.

use serde::{Deserialize, Serialize};
use sx9_foundation_core::data::{DateTime, Utc};

use crate::agents::{BehavioralScope, DriftSignal, DriftVector};

// ============================================================================
// CLSGS ANNEX A.4: GIT LINEAGE TYPES
// ============================================================================

/// A semantic lineage marker from Git history.
///
/// Per CLSGS Annex A.4.1: N-V-N-N annotations function as semantic lineage markers
/// that must persist or be explicitly revised across commits.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LineageMarker {
    /// The N-V-N-N annotation string (e.g., "// FACTORY_GENERATE_RUST_CRATE_SOURCE_CODE")
    pub annotation: String,

    /// Parsed behavioral scope (if valid N-V-N-N format)
    pub behavioral_scope: Option<BehavioralScope>,

    /// File path where annotation exists
    pub file_path: String,

    /// Line number in file
    pub line_number: u32,

    /// Git commit SHA where this marker first appeared
    pub introduced_in: String,

    /// Git commit SHA where this marker was last modified (if different)
    pub last_modified_in: Option<String>,

    /// Whether this marker is still present in HEAD
    pub present_in_head: bool,
}

/// Represents annotation loss across Git history.
///
/// Per CLSGS Annex A.4.1: Loss of annotation is treated as semantic regression,
/// even if code compiles.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnnotationLoss {
    /// The lost annotation
    pub annotation: String,

    /// File where annotation was lost
    pub file_path: String,

    /// Commit SHA where annotation was present
    pub present_in: String,

    /// Commit SHA where annotation was lost
    pub lost_in: String,

    /// Whether this loss was explicitly declared (acceptable)
    pub explicitly_revised: bool,

    /// Drift signal generated by this loss
    pub drift_signal: Option<DriftSignal>,
}

/// Tracks drift longitudinally across commits.
///
/// Per CLSGS Annex A.4.2: Semantic QA evaluates drift by comparing historical
/// annotations to current behavior, detecting gradual responsibility expansion.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LongitudinalDrift {
    /// Commit range analyzed (from..to)
    pub commit_range: (String, String),

    /// Detected annotation losses
    pub annotation_losses: Vec<AnnotationLoss>,

    /// Detected scope expansions (responsibility creep)
    pub scope_expansions: Vec<ScopeExpansion>,

    /// Detected constraint erosions
    pub constraint_erosions: Vec<ConstraintErosion>,

    /// Overall drift score for this range
    pub drift_score: f32,

    /// Whether drift was declared/accepted
    pub drift_declared: bool,

    /// Analysis timestamp
    pub analyzed_at: DateTime<Utc>,
}

/// Responsibility expansion detected across commits.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScopeExpansion {
    /// Component that expanded
    pub component: String,

    /// Original behavioral scope
    pub original_scope: BehavioralScope,

    /// Expanded scope (what it became)
    pub expanded_scope: BehavioralScope,

    /// Commit where expansion was detected
    pub detected_in: String,

    /// Drift vector type
    pub drift_vector: DriftVector,
}

/// Constraint erosion detected across commits.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConstraintErosion {
    /// Component with eroded constraint
    pub component: String,

    /// Original constraint declaration
    pub original_constraint: String,

    /// What constraint became (or empty if removed)
    pub eroded_to: Option<String>,

    /// Commit where erosion was detected
    pub detected_in: String,
}

/// Pull request as an evaluation boundary.
///
/// Per CLSGS Annex A.4.3: Pull requests are evaluation boundaries, not approval mechanisms.
/// Static QA establishes structural admissibility. Semantic QA establishes risk visibility.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PullRequestBoundary {
    /// PR number or identifier
    pub pr_id: String,

    /// Base branch
    pub base_branch: String,

    /// Head branch
    pub head_branch: String,

    /// Merge commit SHA (if merged)
    pub merge_commit: Option<String>,

    /// Static QA result (structural admissibility)
    pub static_qa_passed: bool,

    /// Semantic QA drift signals
    pub drift_signals: Vec<DriftSignal>,

    /// Annotation changes in this PR
    pub annotation_changes: AnnotationChanges,

    /// Whether approval indicates alignment (it does not per CLSGS)
    /// This is always false - approval != alignment
    pub approval_equals_alignment: bool,
}

/// Summary of annotation changes in a commit or PR.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnnotationChanges {
    /// New annotations added
    pub added: Vec<LineageMarker>,

    /// Annotations removed
    pub removed: Vec<AnnotationLoss>,

    /// Annotations modified (old, new)
    pub modified: Vec<(LineageMarker, LineageMarker)>,

    /// Net change in annotation count
    pub net_change: i32,
}

impl Default for AnnotationChanges {
    fn default() -> Self {
        Self {
            added: Vec::new(),
            removed: Vec::new(),
            modified: Vec::new(),
            net_change: 0,
        }
    }
}

/// Git operation types that may affect lineage.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GitOperation {
    Commit,
    Merge,
    Rebase,
    CherryPick,
    Revert,
    Reset,
}

/// Result of lineage analysis on a Git operation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LineageAnalysis {
    /// Git operation type
    pub operation: GitOperation,

    /// Commit SHA analyzed
    pub commit_sha: String,

    /// Parent commit(s) SHA
    pub parent_shas: Vec<String>,

    /// Annotation changes detected
    pub changes: AnnotationChanges,

    /// Semantic regression detected (annotation loss without declaration)
    pub semantic_regression: bool,

    /// Drift signals generated
    pub drift_signals: Vec<DriftSignal>,

    /// Analysis timestamp
    pub analyzed_at: DateTime<Utc>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_annotation_changes_default() {
        let changes = AnnotationChanges::default();
        assert_eq!(changes.net_change, 0);
        assert!(changes.added.is_empty());
        assert!(changes.removed.is_empty());
    }

    #[test]
    fn test_pr_boundary_approval_never_equals_alignment() {
        let pr = PullRequestBoundary {
            pr_id: "123".to_string(),
            base_branch: "main".to_string(),
            head_branch: "feature".to_string(),
            merge_commit: None,
            static_qa_passed: true,
            drift_signals: vec![],
            annotation_changes: AnnotationChanges::default(),
            approval_equals_alignment: false,
        };
        // Per CLSGS A.4.3: Approval does not equal alignment
        assert!(!pr.approval_equals_alignment);
    }
}
