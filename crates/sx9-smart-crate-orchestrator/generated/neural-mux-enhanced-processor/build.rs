//! Build script for neural-mux-enhanced-processor
//!
//! Tesla/SpaceX-grade build-time validation and security enforcement
//! Generated by Smart Crate Orchestrator v0.1.0

use cargo_metadata::MetadataCommand;
use std::env;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=Cargo.lock");
    println!("cargo:rerun-if-env-changed=CTAS_SECURITY_MODE");

    println!("cargo:warning=ðŸ”§ CTAS-7 Build Validation Pipeline");
    println!("cargo:warning=Crate: neural-mux-enhanced-processor");
    println!("cargo:warning=Mission: SystemMonitoring");
    println!("cargo:warning=Security Level: Development");

    // Phase 1: Foundation Dependency Validation
    if let Err(e) = validate_foundation_dependencies() {
        panic!("Foundation dependency validation failed: {}", e);
    }

    // Phase 2: Security Policy Enforcement
    if let Err(e) = enforce_security_policies() {
        panic!("Security policy enforcement failed: {}", e);
    }

    // Phase 3: SLSA Provenance Check
    if let Err(e) = check_slsa_provenance() {
        panic!("SLSA provenance check failed: {}", e);
    }

    // Phase 4: Feature Compatibility Validation
    if let Err(e) = validate_feature_compatibility() {
        panic!("Feature compatibility validation failed: {}", e);
    }

    println!("cargo:warning=âœ… All build validation checks passed");
}

/// Validates CTAS-7 foundation dependencies are correctly pinned
fn validate_foundation_dependencies() -> Result<(), String> {
    println!("cargo:warning=[1/4] Validating foundation dependencies...");

    let metadata = MetadataCommand::new()
        .no_deps()
        .exec()
        .map_err(|e| format!("Failed to read cargo metadata: {}", e))?;

    let foundation_crates = [
        "ctas7-foundation-core",
        "ctas7-foundation-telemetry",
        "ctas7-foundation-ops",
        "ctas7-xsd-p2",
    ];

    for crate_name in &foundation_crates {
        let found = metadata.packages.iter().any(|pkg| {
            pkg.name == *crate_name && pkg.version.to_string() == "1.0.0"
        });

        if !found {
            return Err(format!(
                "Foundation crate {} not found or incorrect version",
                crate_name
            ));
        }
    }

    println!("cargo:warning=    âœ“ Foundation dependencies validated");
    Ok(())
}

/// Enforces security policies based on the crate's security level
fn enforce_security_policies() -> Result<(), String> {
    println!("cargo:warning=[2/4] Enforcing security policies...");

    let security_level = "Development";
    let profile = env::var("PROFILE").unwrap_or_else(|_| "debug".to_string());

    match security_level {
        "Production" | "Classified" => {
            // Enforce release builds for production
            if profile == "debug" {
                return Err(
                    "Production/Classified security levels require release builds"
                        .to_string()
                );
            }

            // Check for security-sensitive environment variables
            if env::var("CTAS_SECURITY_MODE").is_err() {
                return Err(
                    "CTAS_SECURITY_MODE environment variable required for production"
                        .to_string()
                );
            }
        }
        "Staging" => {
            // Warn about debug builds in staging
            if profile == "debug" {
                println!("cargo:warning=âš ï¸  Debug build detected in staging environment");
            }
        }
        "Development" => {
            // Allow debug builds in development
            println!("cargo:warning=ðŸ“ Development mode - relaxed security policies");
        }
        _ => {
            return Err(format!("Unknown security level: {}", security_level));
        }
    }

    println!("cargo:warning=    âœ“ Security policies enforced");
    Ok(())
}

/// Checks for SLSA provenance requirements
fn check_slsa_provenance() -> Result<(), String> {
    println!("cargo:warning=[3/4] Checking SLSA provenance...");

    let profile = env::var("PROFILE").unwrap_or_else(|_| "debug".to_string());
    let is_ci = env::var("CI").is_ok();

    match profile.as_str() {
        "release" | "bench" => {
            if is_ci {
                // In CI/CD pipeline - enforce strict SLSA requirements
                let provenance_file = Path::new("slsa-provenance.json");
                if !provenance_file.exists() {
                    return Err(
                        "SLSA provenance file required for release builds in CI"
                            .to_string()
                    );
                }
                println!("cargo:warning=    âœ“ SLSA provenance verified");
            } else {
                // Local release build - warn but allow
                println!("cargo:warning=    âš ï¸  Local release build - SLSA provenance not enforced");
            }
        }
        _ => {
            // Debug builds don't require SLSA provenance
            println!("cargo:warning=    â—‹ SLSA provenance check skipped for debug builds");
        }
    }

    Ok(())
}

/// Validates feature compatibility and requirements
fn validate_feature_compatibility() -> Result<(), String> {
    println!("cargo:warning=[4/4] Validating feature compatibility...");

    let enabled_features = [
        "production",
        "relaxed-security",
        "xsd-p2",
    ];

    // Check for conflicting features
    let has_dev_mode = enabled_features.contains(&"dev-mode");
    let has_production = enabled_features.contains(&"production");

    if has_dev_mode && has_production {
        return Err(
            "Conflicting features: dev-mode and production cannot be enabled simultaneously"
                .to_string()
        );
    }

    // Validate XSD playbook feature combinations
    let xsd_features: Vec<&str> = enabled_features
        .iter()
        .filter(|f| f.starts_with("xsd-"))
        .copied()
        .collect();

    if xsd_features.len() > 1 {
        return Err(format!(
            "Multiple XSD playbook features detected: {:?}. Only one allowed.",
            xsd_features
        ));
    }

    // Mission-specific feature validation
    match "SystemMonitoring" {
        "CryptographicOperations" => {
            if !enabled_features.contains(&"production-security") &&
               "Development" == "Production" {
                return Err(
                    "CryptographicOperations mission requires production-security feature"
                        .to_string()
                );
            }
        }
        "NeuralInference" => {
            // Neural inference requires specific features
            // Add validation as needed
        }
        _ => {
            // Other missions have standard requirements
        }
    }

    println!("cargo:warning=    âœ“ Feature compatibility validated");
    Ok(())
}