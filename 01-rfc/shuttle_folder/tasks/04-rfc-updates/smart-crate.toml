# CTAS-7 Smart Crate Manifest
# ATLAS Bus - Zero-allocation IPC with Unicode routing

[smart-crate]
name = "sx9-atlas-bus"
version = "0.1.0"
foundation = "sx9-foundation-core"
retrofit_timestamp = "20251214"

[integration]
gold_disk_compatible = true
neural_mux_enabled = true
hash_engine_integrated = true
unicode_assembly_support = true
hft_optimized = true

[metadata]
ctas_version = "7.3.1"
sx9_version = "0.1.0"
smart_crate_type = "ipc"
tesla_grade = true

# ============================================================================
# UNICODE ROUTING TRIGGERS (TOML-native, replaces XSD)
# ============================================================================
# Private Use Area blocks:
#   U+E200-E2FF: CUID slot encoding (context runes)
#   U+E500-E5FF: Command type triggers (routing)
#   U+E600-E6FF: Priority/status encoding
#   U+E700-E7FF: Domain encoding
# ============================================================================

[unicode.triggers]
# Command type triggers (U+E500-E5FF)
atlas_daemon = 0xE500      # ATLAS orchestrator commands
plasma_state = 0xE501      # Plasma field operations
glaf_matroid = 0xE502      # Graph/matroid operations
neural_mux   = 0xE503      # Neural routing
convergence  = 0xE504      # Convergence detection
sdt_gate     = 0xE505      # SDT thyristor control
ooda_cycle   = 0xE506      # OODA loop signals
hd4_phase    = 0xE507      # HD4 phase transitions
tick_sync    = 0xE508      # Tick synchronization
canary_trip  = 0xE509      # Canary/watchdog alerts

[unicode.priority]
# Priority encoding (U+E600-E60F)
critical = 0xE602
urgent   = 0xE601
normal   = 0xE600

[unicode.cuid_base]
# CUID slot runes start at U+E200
# 16 slots map to U+E200-E2FF based on Base96 value
base = 0xE200
range = 0xFF

[unicode.domains]
# Domain encoding (U+E700-E7FF)
space      = 0xE700
maritime   = 0xE701
automotive = 0xE702
osint      = 0xE703
network    = 0xE704
cyber      = 0xE705
kinetic    = 0xE706
industrial = 0xE707
electronic = 0xE708
cbrn       = 0xE709

[unicode.exec_env]
# Execution environment (U+E710-E71F)
wasm        = 0xE710
container   = 0xE711
native      = 0xE712
kernel      = 0xE713
microkernel = 0xE714
firefly     = 0xE715
orb         = 0xE716

[unicode.state]
# Execution state (U+E720-E72F)
cold        = 0xE720
warm        = 0xE721
hot         = 0xE722
l2_resident = 0xE723

[unicode.ui]
# UI Elements - Class E (U+E730-E7DF)
# Pages (U+E730-E74F)
dashboard = 0xE730
hunt      = 0xE731
detect    = 0xE732
disrupt   = 0xE733
disable   = 0xE734
dominate  = 0xE735
tasks     = 0xE736
graph     = 0xE737
streams   = 0xE738
containers = 0xE739
database  = 0xE73A
nyx_trace = 0xE73B
raptor    = 0xE73C
vkali     = 0xE73D
settings  = 0xE73E

[unicode.response]
# Response runes (U+E7E0-E7FF)
success   = 0xE7E0
failure   = 0xE7E1
timeout   = 0xE7E2
partial   = 0xE7E3
queued    = 0xE7E4
running   = 0xE7E5
cancelled = 0xE7E6

[unicode.heredity]
# Lisp-style hash heredity operators (U+E800-E8FF)
# Used for encoding dual trivariate relationships
nil       = 0xE800  # (nil hash cuid) - terminal, no secondary
cons      = 0xE801  # (cons primary secondary) - pair of hashes
car       = 0xE802  # (car pair) - extract primary (semantic)
cdr       = 0xE803  # (cdr pair) - extract secondary (operational)
quote     = 0xE804  # (quote hash) - literal, no evaluation
ref       = 0xE805  # (ref slot) - arena reference
derive    = 0xE806  # (derive parent delta) - derived with delta-angle
xor       = 0xE807  # (xor h1 h2) - XOR combination
chain     = 0xE808  # (chain parent) - hash lineage link
supersede = 0xE809  # (supersede old level) - supersession
fold      = 0xE80A  # (fold hashes...) - Merkle-style fold
lambda    = 0xE80B  # (lambda ctx expr) - deferred computation
apply     = 0xE80C  # (apply fn args) - apply to arena args

# ============================================================================
# CLASS R: TOOL RESPONSE BLOCK (U+E900-E9FF) - RFC-9117
# ============================================================================
# Completes the trigger → execute → respond → process → chain loop

[unicode.response_format]
# Output format markers (U+E900-E90F)
raw        = 0xE900  # Raw bytes (no parsing)
json       = 0xE901  # JSON structured output
xml        = 0xE902  # XML structured output
toml       = 0xE903  # TOML structured output
csv        = 0xE904  # CSV tabular output
ndjson     = 0xE905  # Newline-delimited JSON
grpc       = 0xE906  # gRPC protobuf
msgpack    = 0xE907  # MessagePack binary
stdout     = 0xE908  # Plain text stdout
stderr     = 0xE909  # Plain text stderr
mixed      = 0xE90A  # Combined stdout+stderr
binary     = 0xE90B  # Binary blob (base64 in wire)
stream     = 0xE90C  # Streaming output (chunked)
compressed = 0xE90D  # Compressed (zstd)
encrypted  = 0xE90E  # Encrypted (AES-GCM)

[unicode.response_size]
# Output size class (U+E910-E91F)
tiny     = 0xE910  # < 256 bytes
small    = 0xE911  # 256B - 4KB
medium   = 0xE912  # 4KB - 64KB
large    = 0xE913  # 64KB - 1MB
xlarge   = 0xE914  # 1MB - 16MB
huge     = 0xE915  # 16MB - 256MB
chunked  = 0xE916  # Streaming (unknown size)
empty    = 0xE917  # No output (0 bytes)

[unicode.response_parser]
# Parser hints (U+E920-E92F) - tells receiver how to parse
nmap_xml       = 0xE920  # nmap -oX output
nmap_grep      = 0xE921  # nmap -oG output
masscan_json   = 0xE922  # masscan -oJ output
nuclei_json    = 0xE923  # nuclei -json output
nikto_csv      = 0xE924  # nikto -Format csv
sqlmap_json    = 0xE925  # sqlmap --dump-format=JSON
hashcat_pot    = 0xE926  # hashcat potfile format
john_pot       = 0xE927  # john potfile format
harvester_json = 0xE928  # theHarvester JSON
amass_json     = 0xE929  # amass JSON output
subfinder_json = 0xE92A  # subfinder JSON
sigma_match    = 0xE92B  # Sigma rule match
yara_match     = 0xE92C  # YARA rule match
caldera_op     = 0xE92D  # Caldera operation result
atomic_test    = 0xE92E  # Atomic Red Team result
generic        = 0xE92F  # Generic parser

[unicode.response_chaining]
# Chaining directives (U+E9C0-E9DF) - what to do next
chain_next        = 0xE9C0  # Trigger next tool in chain
chain_parallel    = 0xE9C1  # Trigger parallel tools
chain_conditional = 0xE9C2  # Conditional next (if success)
chain_branch      = 0xE9C3  # Branch based on output
chain_merge       = 0xE9C4  # Merge multiple outputs
chain_filter      = 0xE9C5  # Filter output before next
chain_transform   = 0xE9C6  # Transform output format
chain_store       = 0xE9C7  # Store to arena, continue
chain_emit        = 0xE9C8  # Emit to NATS, continue
chain_terminate   = 0xE9C9  # End chain
chain_retry       = 0xE9CA  # Retry on failure
chain_timeout     = 0xE9CB  # Timeout handling
chain_escalate    = 0xE9CC  # Escalate tier
chain_deescalate  = 0xE9CD  # De-escalate tier

# ============================================================================
# 32 PRIMITIVES - All commands map to exactly one primitive
# ============================================================================
# 8 categories × 4 primitives = 32 total
# Trigger rune = 0xE500 + primitive_id (0-31)

[primitives.graph]
# Category 0: Graph operations (U+E500-E503)
traverse  = { id = 0, trigger = 0xE500, desc = "Path finding (Dijkstra, BFS, DFS)" }
search    = { id = 1, trigger = 0xE501, desc = "Pattern matching, lookup" }
aggregate = { id = 2, trigger = 0xE502, desc = "Collect, fold, reduce" }
transform = { id = 3, trigger = 0xE503, desc = "Map, filter, project" }

[primitives.matroid]
# Category 1: Matroid operations (U+E504-E507)
rank    = { id = 4, trigger = 0xE504, desc = "Independence rank" }
closure = { id = 5, trigger = 0xE505, desc = "Matroid closure" }
circuit = { id = 6, trigger = 0xE506, desc = "Circuit detection" }
span    = { id = 7, trigger = 0xE507, desc = "Spanning set operations" }

[primitives.convergence]
# Category 2: Convergence operations (U+E508-E50B)
detect    = { id = 8, trigger = 0xE508, desc = "Convergence detection" }
measure   = { id = 9, trigger = 0xE509, desc = "Rate measurement" }
threshold = { id = 10, trigger = 0xE50A, desc = "Threshold checking" }
stabilize = { id = 11, trigger = 0xE50B, desc = "Stability operations" }

[primitives.hash]
# Category 3: Hash operations (U+E50C-E50F)
compute = { id = 12, trigger = 0xE50C, desc = "Hash generation" }
verify  = { id = 13, trigger = 0xE50D, desc = "Hash verification" }
chain   = { id = 14, trigger = 0xE50E, desc = "Hash chaining" }
derive  = { id = 15, trigger = 0xE50F, desc = "Hash derivation" }

[primitives.tick]
# Category 4: Tick operations (U+E510-E513)
sync    = { id = 16, trigger = 0xE510, desc = "Tick synchronization" }
query   = { id = 17, trigger = 0xE511, desc = "Tick status query" }
advance = { id = 18, trigger = 0xE512, desc = "Tick advancement" }
reset   = { id = 19, trigger = 0xE513, desc = "Tick reset" }

[primitives.sdt]
# Category 5: SDT/Gate operations (U+E514-E517)
trigger   = { id = 20, trigger = 0xE514, desc = "SDT thyristor trigger" }
release   = { id = 21, trigger = 0xE515, desc = "SDT release" }
gate_query = { id = 22, trigger = 0xE516, desc = "Gate status query" }
configure = { id = 23, trigger = 0xE517, desc = "Gate configuration" }

[primitives.plasma]
# Category 6: Plasma operations (U+E518-E51B)
excite       = { id = 24, trigger = 0xE518, desc = "Plasma excitation" }
dampen       = { id = 25, trigger = 0xE519, desc = "Plasma dampening" }
plasma_query = { id = 26, trigger = 0xE51A, desc = "Field query" }
couple       = { id = 27, trigger = 0xE51B, desc = "Field coupling" }

[primitives.control]
# Category 7: Control operations (U+E51C-E51F)
ping      = { id = 28, trigger = 0xE51C, desc = "Health check" }
stats     = { id = 29, trigger = 0xE51D, desc = "Statistics request" }
shutdown  = { id = 30, trigger = 0xE51E, desc = "Graceful shutdown" }
emergency = { id = 31, trigger = 0xE51F, desc = "Emergency stop" }

# ============================================================================
# TRIVARIATE HASH CONFIGURATION
# ============================================================================

[trivariate]
# Hash component sizes
sch_bits = 128          # Murmur3-128
cuid_slots = 16         # 16 Base96 characters
uuid_version = 4        # UUIDv4

# Packed reference size for HFT
packed_ref_bits = 128   # TrivariateRef = u64 + u64

[trivariate.ttl]
# CUID TTL values (canonical 42)
default_seconds = 42
hot_lane_ms = 4200
l2_kernel_ms = 420

[trivariate.supersession]
# Delta-angle thresholds (degrees)
none_threshold = 2.0      # < 2° = noise
micro_threshold = 12.0    # 2-12° = local context
soft_threshold = 27.0     # 12-27° = operator shift
hard_threshold = 42.0     # 27-42° = state mutation
# > 42° = critical (domain change)

# ============================================================================
# COMMAND ENCODING
# ============================================================================

[command.small]
# SmallCommand: 64 bytes, cache-line aligned
size_bytes = 64
cache_aligned = true
triv_ref_bytes = 16       # TrivariateRef
payload_bytes = 24        # Inline small payloads

[command.large]
# LargePayload: stored in arena, referenced by hash
arena_indexed = true
ttl_enforced = true
supersession_gated = true

[command.kinds]
# Small commands (inline payload fits 24 bytes)
small = [
    "Dijkstra",       # src: u32, dst: u32, max_hops: u8 = 9 bytes
    "Bfs",            # src: u32, max_depth: u8 = 5 bytes
    "Ping",           # seq: u32, timestamp_ns: u64 = 12 bytes
    "SdtTrigger",     # gate_id: u32, reason: u16 = 6 bytes
    "SdtReset",       # gate_id: u32 = 4 bytes
    "PlasmaQuery",    # field_id: u32 = 4 bytes
    "TickSync",       # tick_id: u64, timestamp_ns: u64 = 16 bytes
    "ConvergenceCheck", # entity_id: u32, epsilon: f32, window: u16 = 10 bytes
    "Stats",          # empty = 0 bytes
    "Shutdown",       # empty = 0 bytes
]

# Large commands (payload in arena)
large = [
    "MatroidRank",       # nodes: Vec<u32>
    "MatroidIndependent", # nodes: Vec<u32>
    "MaxIndependentSet", # nodes: Vec<u32>
    "AllPaths",          # paths result
    "BatchHash",         # data: Vec<u8>
]

# ============================================================================
# RING BUFFER CONFIGURATION
# ============================================================================

[ring]
# Lane sizes (power of 2)
critical_size = 256
urgent_size = 1024
normal_size = 4096
result_size = 4096

# HFT settings
cache_line_bytes = 64
spsc_optimized = true
lock_free = true

[ring.backpressure]
warning_threshold = 0.7
critical_threshold = 0.9

# ============================================================================
# ENDPOINTS
# ============================================================================

[endpoints]
health = "/health"
status = "/status"
metrics = "/metrics"
plasma = "/plasma"

[features]
std = { default = true }
nats = { optional = true, deps = ["async-nats"] }
wasm = { optional = true }
hft = { optional = true, deps = ["crossbeam-utils"] }
