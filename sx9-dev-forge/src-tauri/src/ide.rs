//! IDE Bootstrap File Generation for SX9 Dev Forge

use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum IdeError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),
    #[error("YAML error: {0}")]
    Yaml(#[from] serde_yaml::Error),
    #[error("Unsupported IDE: {0}")]
    UnsupportedIde(String),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum IdeType {
    Cursor,
    Vscode,
    Antigravity,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BootstrapConfig {
    pub ide: IdeType,
    pub project_path: PathBuf,
    pub persona: String,
    pub harness: String,
    pub mission_title: String,
    pub mission_id: String,
    pub constraints: BootstrapConstraints,
    pub context: BootstrapContext,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BootstrapConstraints {
    pub hard: Vec<String>,
    pub soft: Vec<String>,
    pub forbidden_paths: Vec<String>,
    pub max_file_lines: Option<u32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BootstrapContext {
    pub rfcs: Vec<String>,
    pub linear_issue: Option<String>,
    pub working_directory: String,
}

pub struct IdeBootstrap {
    config: BootstrapConfig,
}

impl IdeBootstrap {
    pub fn new(config: BootstrapConfig) -> Self {
        Self { config }
    }

    pub fn generate(&self) -> Result<Vec<(PathBuf, String)>, IdeError> {
        match self.config.ide {
            IdeType::Cursor => self.generate_cursor(),
            IdeType::Vscode => self.generate_vscode(),
            IdeType::Antigravity => self.generate_antigravity(),
        }
    }

    fn generate_cursor(&self) -> Result<Vec<(PathBuf, String)>, IdeError> {
        let mut files = vec![];

        // .cursorrules
        let cursorrules = self.generate_cursorrules();
        files.push((
            self.config.project_path.join(".cursorrules"),
            cursorrules,
        ));

        // CONTEXT.md
        let context_md = self.generate_context_md();
        files.push((
            self.config.project_path.join("CONTEXT.md"),
            context_md,
        ));

        // .cursor/settings.json
        let cursor_settings = self.generate_cursor_settings()?;
        let cursor_dir = self.config.project_path.join(".cursor");
        files.push((cursor_dir.join("settings.json"), cursor_settings));

        Ok(files)
    }

    fn generate_vscode(&self) -> Result<Vec<(PathBuf, String)>, IdeError> {
        let mut files = vec![];

        // .vscode/settings.json
        let settings = self.generate_vscode_settings()?;
        let vscode_dir = self.config.project_path.join(".vscode");
        files.push((vscode_dir.join("settings.json"), settings));

        // .vscode/tasks.json
        let tasks = self.generate_vscode_tasks()?;
        files.push((vscode_dir.join("tasks.json"), tasks));

        // MISSION.yaml
        let mission = self.generate_mission_yaml()?;
        files.push((self.config.project_path.join("MISSION.yaml"), mission));

        Ok(files)
    }

    fn generate_antigravity(&self) -> Result<Vec<(PathBuf, String)>, IdeError> {
        let mut files = vec![];

        // .agrc
        let agrc = self.generate_agrc()?;
        files.push((self.config.project_path.join(".agrc"), agrc));

        // context/mission.yaml
        let context_dir = self.config.project_path.join("context");
        let mission = self.generate_mission_yaml()?;
        files.push((context_dir.join("mission.yaml"), mission));

        Ok(files)
    }

    fn generate_cursorrules(&self) -> String {
        let hard_constraints = self.config.constraints.hard
            .iter()
            .map(|c| format!("- {}", c))
            .collect::<Vec<_>>()
            .join("\n");

        let soft_constraints = self.config.constraints.soft
            .iter()
            .map(|c| format!("- {}", c))
            .collect::<Vec<_>>()
            .join("\n");

        let forbidden = self.config.constraints.forbidden_paths
            .iter()
            .map(|p| format!("- {}", p))
            .collect::<Vec<_>>()
            .join("\n");

        let rfcs = self.config.context.rfcs
            .iter()
            .map(|r| format!("- {}", r))
            .collect::<Vec<_>>()
            .join("\n");

        format!(r#"# SX9 Dev Forge - Cursor Rules
# Mission: {}
# ID: {}
# Generated by SX9 Dev Forge

## PERSONA
You are {}, operating under the {} harness.

## HARD CONSTRAINTS (MUST follow)
{}

## SOFT CONSTRAINTS (SHOULD follow)
{}

## FORBIDDEN PATHS (DO NOT modify)
{}

## CONTEXT
### Related RFCs
{}

### Linear Issue
{}

### Working Directory
{}

## CODE STANDARDS
- Maximum lines per file: {}
- Always run tests before committing
- Document all public APIs
- Follow existing code conventions

## ON COMPLETION
- Update Linear issue with results
- Summarize deliverables
- Note any constraint violations
"#,
            self.config.mission_title,
            self.config.mission_id,
            self.config.persona,
            self.config.harness,
            hard_constraints,
            soft_constraints,
            forbidden,
            rfcs,
            self.config.context.linear_issue.as_deref().unwrap_or("None"),
            self.config.context.working_directory,
            self.config.constraints.max_file_lines.unwrap_or(300)
        )
    }

    fn generate_context_md(&self) -> String {
        format!(r#"# Mission Context

## {} 
**ID:** {}  
**Persona:** {}  
**Harness:** {}

## Constraints

### Hard Constraints
{}

### Soft Constraints
{}

## Related RFCs
{}

## Linear Integration
{}

---
*Generated by SX9 Dev Forge*
"#,
            self.config.mission_title,
            self.config.mission_id,
            self.config.persona,
            self.config.harness,
            self.config.constraints.hard.iter().map(|c| format!("- {}", c)).collect::<Vec<_>>().join("\n"),
            self.config.constraints.soft.iter().map(|c| format!("- {}", c)).collect::<Vec<_>>().join("\n"),
            self.config.context.rfcs.iter().map(|r| format!("- {}", r)).collect::<Vec<_>>().join("\n"),
            self.config.context.linear_issue.as_deref().unwrap_or("Not linked")
        )
    }

    fn generate_cursor_settings(&self) -> Result<String, IdeError> {
        let settings = serde_json::json!({
            "sx9.mission.id": self.config.mission_id,
            "sx9.mission.title": self.config.mission_title,
            "sx9.persona": self.config.persona,
            "sx9.harness": self.config.harness,
            "sx9.linear.issue": self.config.context.linear_issue,
        });

        Ok(serde_json::to_string_pretty(&settings)?)
    }

    fn generate_vscode_settings(&self) -> Result<String, IdeError> {
        let settings = serde_json::json!({
            "files.exclude": {
                "**/.git": true,
                "**/node_modules": true,
                "**/target": true
            },
            "editor.formatOnSave": true,
            "sx9.mission.id": self.config.mission_id,
            "sx9.mission.title": self.config.mission_title,
            "sx9.persona": self.config.persona,
            "sx9.harness": self.config.harness,
        });

        Ok(serde_json::to_string_pretty(&settings)?)
    }

    fn generate_vscode_tasks(&self) -> Result<String, IdeError> {
        let tasks = serde_json::json!({
            "version": "2.0.0",
            "tasks": [
                {
                    "label": "SX9: Checkpoint",
                    "type": "shell",
                    "command": "echo 'Checkpoint logged for mission {}'",
                    "problemMatcher": []
                },
                {
                    "label": "SX9: Complete Mission",
                    "type": "shell", 
                    "command": "echo 'Mission {} completed'",
                    "problemMatcher": []
                }
            ]
        });

        Ok(serde_json::to_string_pretty(&tasks)?)
    }

    fn generate_mission_yaml(&self) -> Result<String, IdeError> {
        let yaml = serde_yaml::to_string(&serde_json::json!({
            "mission": {
                "id": self.config.mission_id,
                "title": self.config.mission_title,
                "persona": self.config.persona,
                "harness": self.config.harness,
            },
            "constraints": {
                "hard": self.config.constraints.hard,
                "soft": self.config.constraints.soft,
                "forbidden_paths": self.config.constraints.forbidden_paths,
            },
            "context": {
                "rfcs": self.config.context.rfcs,
                "linear_issue": self.config.context.linear_issue,
                "working_directory": self.config.context.working_directory,
            }
        }))?;

        Ok(yaml)
    }

    fn generate_agrc(&self) -> Result<String, IdeError> {
        let agrc = serde_json::json!({
            "version": "1.0",
            "mission": self.config.mission_id,
            "persona": self.config.persona,
            "harness": self.config.harness,
            "context_dir": "context/",
            "constraints": {
                "forbidden": self.config.constraints.forbidden_paths,
                "max_lines": self.config.constraints.max_file_lines,
            }
        });

        Ok(serde_json::to_string_pretty(&agrc)?)
    }

    /// Write all generated files to disk
    pub fn write_files(&self) -> Result<Vec<PathBuf>, IdeError> {
        let files = self.generate()?;
        let mut written = vec![];

        for (path, content) in files {
            if let Some(parent) = path.parent() {
                std::fs::create_dir_all(parent)?;
            }
            std::fs::write(&path, content)?;
            written.push(path);
        }

        Ok(written)
    }
}

/// Open IDE with the project
pub fn open_ide(ide: IdeType, project_path: &Path) -> Result<(), IdeError> {
    let command = match ide {
        IdeType::Cursor => "cursor",
        IdeType::Vscode => "code",
        IdeType::Antigravity => "antigravity",
    };

    std::process::Command::new(command)
        .arg(project_path)
        .spawn()
        .map_err(|e| IdeError::Io(e))?;

    Ok(())
}
