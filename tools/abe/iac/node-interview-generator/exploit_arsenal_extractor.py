#!/usr/bin/env python3
"""
Extract Kali tools from ctas7-exploit-arsenal and fetch ExploitDB
Integrates with threat_vector_pipeline for complete coverage.
"""

import json
import os
import subprocess
import re
from pathlib import Path
from typing import Dict, List

OUTPUT_DIR = Path(__file__).parent / "output"
THREAT_DIR = OUTPUT_DIR / "threat_content"
EXPLOIT_ARSENAL_PATH = Path(__file__).parent.parent.parent / "ctas7-exploit-arsenal"

# Comprehensive Kali tools from exploit-arsenal (parsed from Rust)
KALI_TOOLS_COMPREHENSIVE = {
    "NetworkRecon": [
        {"name": "nmap", "package": "nmap", "desc": "Network discovery and security auditing", "deployment": "bare_metal", "risk": "low"},
        {"name": "masscan", "package": "masscan", "desc": "High-speed TCP port scanner", "deployment": "bare_metal", "risk": "low"},
        {"name": "netdiscover", "package": "netdiscover", "desc": "Network scanning and live host discovery", "deployment": "iso", "risk": "safe"},
        {"name": "arp-scan", "package": "arp-scan", "desc": "ARP scanning and fingerprinting", "deployment": "bare_metal", "risk": "safe"},
        {"name": "unicornscan", "package": "unicornscan", "desc": "Stateless TCP/UDP port scanner", "deployment": "iso", "risk": "low"},
        {"name": "hping3", "package": "hping3", "desc": "TCP/IP packet assembler/analyzer", "deployment": "bare_metal", "risk": "medium"},
        {"name": "fping", "package": "fping", "desc": "Fast ping sweep", "deployment": "bare_metal", "risk": "safe"},
        {"name": "nbtscan", "package": "nbtscan", "desc": "NetBIOS scanner", "deployment": "bare_metal", "risk": "safe"},
    ],
    "WebApplicationTesting": [
        {"name": "nikto", "package": "nikto", "desc": "Web server scanner", "deployment": "bare_metal", "risk": "low"},
        {"name": "sqlmap", "package": "sqlmap", "desc": "Automatic SQL injection testing", "deployment": "bare_metal", "risk": "high"},
        {"name": "gobuster", "package": "gobuster", "desc": "Directory/file brute-forcing", "deployment": "bare_metal", "risk": "medium"},
        {"name": "dirb", "package": "dirb", "desc": "Web content scanner", "deployment": "bare_metal", "risk": "medium"},
        {"name": "wfuzz", "package": "wfuzz", "desc": "Web application fuzzer", "deployment": "bare_metal", "risk": "medium"},
        {"name": "burpsuite", "package": "burpsuite", "desc": "Web security testing platform", "deployment": "iso", "risk": "medium"},
        {"name": "zaproxy", "package": "zaproxy", "desc": "OWASP ZAP web app scanner", "deployment": "iso", "risk": "medium"},
        {"name": "wpscan", "package": "wpscan", "desc": "WordPress security scanner", "deployment": "bare_metal", "risk": "low"},
        {"name": "whatweb", "package": "whatweb", "desc": "Web technology fingerprinter", "deployment": "bare_metal", "risk": "safe"},
        {"name": "commix", "package": "commix", "desc": "Command injection exploiter", "deployment": "bare_metal", "risk": "high"},
    ],
    "ExploitationFrameworks": [
        {"name": "metasploit", "package": "metasploit-framework", "desc": "Penetration testing framework", "deployment": "bare_metal", "risk": "critical"},
        {"name": "armitage", "package": "armitage", "desc": "Graphical cyber attack management for MSF", "deployment": "iso", "risk": "critical"},
        {"name": "beef-xss", "package": "beef-xss", "desc": "Browser Exploitation Framework", "deployment": "iso", "risk": "high"},
        {"name": "set", "package": "set", "desc": "Social Engineer Toolkit", "deployment": "bare_metal", "risk": "high"},
        {"name": "exploitdb", "package": "exploitdb", "desc": "Exploit database searchsploit", "deployment": "bare_metal", "risk": "high"},
        {"name": "msfpc", "package": "msfpc", "desc": "MSFvenom Payload Creator", "deployment": "bare_metal", "risk": "critical"},
    ],
    "PasswordCracking": [
        {"name": "hydra", "package": "hydra", "desc": "Online password cracking tool", "deployment": "hybrid", "risk": "high"},
        {"name": "hashcat", "package": "hashcat", "desc": "Advanced password recovery (GPU)", "deployment": "iso", "risk": "medium"},
        {"name": "john", "package": "john", "desc": "John the Ripper password cracker", "deployment": "hybrid", "risk": "medium"},
        {"name": "medusa", "package": "medusa", "desc": "Parallel login brute-forcer", "deployment": "bare_metal", "risk": "high"},
        {"name": "ncrack", "package": "ncrack", "desc": "Network authentication cracker", "deployment": "bare_metal", "risk": "high"},
        {"name": "ophcrack", "package": "ophcrack", "desc": "Windows password cracker", "deployment": "iso", "risk": "medium"},
        {"name": "cewl", "package": "cewl", "desc": "Custom wordlist generator", "deployment": "bare_metal", "risk": "safe"},
        {"name": "crunch", "package": "crunch", "desc": "Wordlist generator", "deployment": "bare_metal", "risk": "safe"},
    ],
    "WirelessNetworks": [
        {"name": "aircrack-ng", "package": "aircrack-ng", "desc": "WiFi network security assessment", "deployment": "iso", "risk": "high"},
        {"name": "wifite", "package": "wifite", "desc": "Automated wireless auditor", "deployment": "iso", "risk": "high"},
        {"name": "reaver", "package": "reaver", "desc": "WPS brute force attack", "deployment": "iso", "risk": "high"},
        {"name": "fern-wifi-cracker", "package": "fern-wifi-cracker", "desc": "WiFi security auditing GUI", "deployment": "iso", "risk": "high"},
        {"name": "kismet", "package": "kismet", "desc": "Wireless network detector/sniffer", "deployment": "iso", "risk": "medium"},
        {"name": "bully", "package": "bully", "desc": "WPS brute force implementation", "deployment": "iso", "risk": "high"},
    ],
    "OSINT": [
        {"name": "theharvester", "package": "theharvester", "desc": "Email/subdomain harvester", "deployment": "bare_metal", "risk": "safe"},
        {"name": "recon-ng", "package": "recon-ng", "desc": "Web reconnaissance framework", "deployment": "hybrid", "risk": "safe"},
        {"name": "maltego", "package": "maltego", "desc": "OSINT and forensics application", "deployment": "iso", "risk": "safe"},
        {"name": "spiderfoot", "package": "spiderfoot", "desc": "OSINT automation tool", "deployment": "bare_metal", "risk": "safe"},
        {"name": "shodan", "package": "shodan", "desc": "Shodan CLI search tool", "deployment": "bare_metal", "risk": "safe"},
        {"name": "amass", "package": "amass", "desc": "Network mapping/asset discovery", "deployment": "bare_metal", "risk": "safe"},
        {"name": "subfinder", "package": "subfinder", "desc": "Subdomain discovery tool", "deployment": "bare_metal", "risk": "safe"},
    ],
    "Forensics": [
        {"name": "autopsy", "package": "autopsy", "desc": "Digital forensics platform", "deployment": "iso", "risk": "safe"},
        {"name": "binwalk", "package": "binwalk", "desc": "Firmware analysis tool", "deployment": "iso", "risk": "safe"},
        {"name": "volatility", "package": "volatility3", "desc": "Memory forensics framework", "deployment": "iso", "risk": "safe"},
        {"name": "sleuthkit", "package": "sleuthkit", "desc": "File system forensics toolkit", "deployment": "iso", "risk": "safe"},
        {"name": "foremost", "package": "foremost", "desc": "File carving tool", "deployment": "iso", "risk": "safe"},
        {"name": "bulk_extractor", "package": "bulk-extractor", "desc": "Extract features from disk images", "deployment": "iso", "risk": "safe"},
    ],
    "ReverseEngineering": [
        {"name": "ghidra", "package": "ghidra", "desc": "NSA reverse engineering suite", "deployment": "iso", "risk": "safe"},
        {"name": "radare2", "package": "radare2", "desc": "Reverse engineering framework", "deployment": "bare_metal", "risk": "safe"},
        {"name": "gdb", "package": "gdb", "desc": "GNU Debugger", "deployment": "bare_metal", "risk": "safe"},
        {"name": "objdump", "package": "binutils", "desc": "Display info from object files", "deployment": "bare_metal", "risk": "safe"},
        {"name": "strace", "package": "strace", "desc": "System call tracer", "deployment": "bare_metal", "risk": "safe"},
    ],
    "Sniffing": [
        {"name": "wireshark", "package": "wireshark", "desc": "Network protocol analyzer", "deployment": "hybrid", "risk": "safe"},
        {"name": "tcpdump", "package": "tcpdump", "desc": "Command-line packet analyzer", "deployment": "bare_metal", "risk": "safe"},
        {"name": "ettercap", "package": "ettercap-graphical", "desc": "MitM attack suite", "deployment": "iso", "risk": "high"},
        {"name": "bettercap", "package": "bettercap", "desc": "Network attack and monitoring", "deployment": "bare_metal", "risk": "high"},
        {"name": "dsniff", "package": "dsniff", "desc": "Password sniffer", "deployment": "iso", "risk": "high"},
        {"name": "responder", "package": "responder", "desc": "LLMNR/NBT-NS/mDNS Poisoner", "deployment": "bare_metal", "risk": "high"},
    ],
    "VulnerabilityAnalysis": [
        {"name": "nessus", "package": "nessus", "desc": "Vulnerability scanner (commercial)", "deployment": "bare_metal", "risk": "low"},
        {"name": "openvas", "package": "openvas", "desc": "Open vulnerability assessment", "deployment": "iso", "risk": "low"},
        {"name": "lynis", "package": "lynis", "desc": "Security auditing tool", "deployment": "bare_metal", "risk": "safe"},
        {"name": "wapiti", "package": "wapiti", "desc": "Web application vulnerability scanner", "deployment": "bare_metal", "risk": "medium"},
        {"name": "nuclei", "package": "nuclei", "desc": "Template-based vulnerability scanner", "deployment": "bare_metal", "risk": "medium"},
    ],
    "PostExploitation": [
        {"name": "empire", "package": "powershell-empire", "desc": "PowerShell post-exploitation agent", "deployment": "bare_metal", "risk": "critical"},
        {"name": "covenant", "package": "covenant", "desc": ".NET C2 framework", "deployment": "iso", "risk": "critical"},
        {"name": "sliver", "package": "sliver", "desc": "Adversary emulation framework", "deployment": "bare_metal", "risk": "critical"},
        {"name": "bloodhound", "package": "bloodhound", "desc": "AD attack path analysis", "deployment": "bare_metal", "risk": "medium"},
        {"name": "mimikatz", "package": "mimikatz", "desc": "Windows credential extraction", "deployment": "bare_metal", "risk": "critical"},
        {"name": "crackmapexec", "package": "crackmapexec", "desc": "Windows/AD post-exploitation", "deployment": "bare_metal", "risk": "high"},
        {"name": "evil-winrm", "package": "evil-winrm", "desc": "WinRM shell for pentesting", "deployment": "bare_metal", "risk": "high"},
    ],
}


def extract_kali_tools() -> Dict:
    """Extract comprehensive Kali tools inventory."""
    print("=== Extracting Kali Tools Inventory ===")
    
    tools_list = []
    for category, tools in KALI_TOOLS_COMPREHENSIVE.items():
        for tool in tools:
            tools_list.append({
                "name": tool["name"],
                "package_name": tool["package"],
                "display_name": tool["name"].replace("-", " ").title(),
                "description": tool["desc"],
                "category": category,
                "deployment_type": tool["deployment"],
                "risk_level": tool["risk"],
                "mitre_techniques": [],  # Will be enriched by crosswalk
            })
    
    inventory = {
        "source": "ctas7-exploit-arsenal",
        "version": "7.3.1",
        "tool_count": len(tools_list),
        "categories": list(KALI_TOOLS_COMPREHENSIVE.keys()),
        "tools": tools_list,
    }
    
    # Save to threat_content directory
    THREAT_DIR.mkdir(parents=True, exist_ok=True)
    output_file = THREAT_DIR / "kali_tools_inventory.json"
    with open(output_file, 'w') as f:
        json.dump(inventory, f, indent=2)
    
    print(f"  Exported {len(tools_list)} tools to {output_file}")
    return inventory


def fetch_exploitdb(clone_depth: int = 1) -> int:
    """Fetch ExploitDB from GitLab."""
    print("\n=== Fetching ExploitDB ===")
    repo_dir = THREAT_DIR / "exploitdb"
    
    try:
        if repo_dir.exists():
            print("  ExploitDB already exists, pulling updates...")
            subprocess.run(["git", "-C", str(repo_dir), "pull", "--depth", "1"],
                         capture_output=True, timeout=300)
        else:
            print("  Cloning ExploitDB (this may take a while)...")
            # Sparse checkout just the exploits directory
            subprocess.run([
                "git", "clone", "--depth", str(clone_depth), "--filter=blob:none", "--sparse",
                "https://gitlab.com/exploit-database/exploitdb.git", str(repo_dir)
            ], capture_output=True, timeout=600)
            subprocess.run(
                ["git", "-C", str(repo_dir), "sparse-checkout", "set", "exploits"],
                capture_output=True, timeout=60
            )
        
        # Count exploits
        exploits_dir = repo_dir / "exploits"
        if exploits_dir.exists():
            count = sum(1 for _ in exploits_dir.rglob("*.txt")) + sum(1 for _ in exploits_dir.rglob("*.py"))
            print(f"  Found {count} exploit files")
            return count
        return 0
        
    except Exception as e:
        print(f"  ERROR: {e}")
        return 0


def create_exploit_index() -> Dict:
    """Create searchable index of ExploitDB."""
    print("\n=== Creating ExploitDB Index ===")
    exploits_dir = THREAT_DIR / "exploitdb" / "exploits"
    
    if not exploits_dir.exists():
        print("  ExploitDB not found, skipping index")
        return {}
    
    index = {
        "categories": {},
        "exploits": [],
    }
    
    count = 0
    for category_dir in exploits_dir.iterdir():
        if category_dir.is_dir():
            category = category_dir.name
            if category not in index["categories"]:
                index["categories"][category] = 0
            
            for exploit_file in list(category_dir.rglob("*"))[:100]:  # Limit per category
                if exploit_file.is_file() and exploit_file.suffix in ['.txt', '.py', '.rb', '.c', '.sh']:
                    index["exploits"].append({
                        "id": exploit_file.stem,
                        "category": category,
                        "filename": exploit_file.name,
                        "type": exploit_file.suffix[1:],
                    })
                    index["categories"][category] += 1
                    count += 1
                    
                    if count >= 2000:  # Total limit
                        break
        if count >= 2000:
            break
    
    # Save index
    index_file = THREAT_DIR / "exploitdb_index.json"
    with open(index_file, 'w') as f:
        json.dump(index, f, indent=2)
    
    print(f"  Indexed {count} exploits across {len(index['categories'])} categories")
    return index


def main():
    print("=" * 60)
    print("Exploit Arsenal & ExploitDB Integration")
    print("=" * 60)
    
    # Extract Kali tools
    kali_inventory = extract_kali_tools()
    
    # Fetch ExploitDB
    exploit_count = fetch_exploitdb()
    
    # Create index
    if exploit_count > 0:
        exploit_index = create_exploit_index()
    
    print("\n" + "=" * 60)
    print("Summary:")
    print(f"  Kali Tools: {kali_inventory['tool_count']}")
    print(f"  ExploitDB: {exploit_count} files")
    print("=" * 60)


if __name__ == "__main__":
    main()
