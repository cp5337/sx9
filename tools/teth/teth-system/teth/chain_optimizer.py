"""
TETH - Tool Entropy Testing Harness
Chain Optimization with Hungarian Algorithm

Optimize tool chains for stealth, speed, or coverage.
"""

from __future__ import annotations
import math
from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple

try:
    import numpy as np
    from scipy.optimize import linear_sum_assignment
    HAS_SCIPY = True
except ImportError:
    HAS_SCIPY = False

from .entropy_models import (
    HD4Phase, PersonaLevel, Tool, TOOL_DATABASE, 
    calculate_chain_entropy, get_tools_by_persona
)


# ═══════════════════════════════════════════════════════════════════════════════
# OPTIMIZATION OBJECTIVES
# ═══════════════════════════════════════════════════════════════════════════════

class OptimizationObjective(Enum):
    STEALTH = "stealth"       # Minimize detection risk
    SPEED = "speed"           # Minimize cognitive overhead
    COVERAGE = "coverage"     # Maximize phase coverage
    BALANCED = "balanced"     # Multi-objective


# ═══════════════════════════════════════════════════════════════════════════════
# DATA CLASSES
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class ChainConstraints:
    """Constraints for chain optimization."""
    max_entropy: float = 100.0
    max_tools: int = 10
    required_phases: List[HD4Phase] = field(default_factory=list)
    forbidden_tools: List[str] = field(default_factory=list)
    persona_level: PersonaLevel = PersonaLevel.CARTEL
    time_limit_hours: Optional[float] = None
    stealth_minimum: float = 0.0


@dataclass
class OptimizedChain:
    """Result of chain optimization."""
    tools: List[Tool]
    total_entropy: float
    estimated_success: float
    objective_score: float
    objective: OptimizationObjective
    phases_covered: List[HD4Phase]
    
    @property
    def tool_ids(self) -> List[str]:
        return [t.id for t in self.tools]


# ═══════════════════════════════════════════════════════════════════════════════
# COST FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

def transition_noise(from_tool: Tool, to_tool: Tool) -> float:
    """Calculate noise generated by transitioning between tools."""
    # Same category = smoother transition
    if from_tool.category == to_tool.category:
        return 0.1
    
    # Phase progression = natural flow
    phase_order = [HD4Phase.HUNT, HD4Phase.DETECT, HD4Phase.DISRUPT, 
                   HD4Phase.DISABLE, HD4Phase.DOMINATE]
    from_idx = phase_order.index(from_tool.hd4_phase)
    to_idx = phase_order.index(to_tool.hd4_phase)
    
    if to_idx == from_idx + 1:  # Natural progression
        return 0.2
    elif to_idx > from_idx:  # Skip phases
        return 0.5 * (to_idx - from_idx)
    else:  # Regression
        return 1.0
    

def transition_time(from_tool: Tool, to_tool: Tool) -> float:
    """Estimate time to transition between tools (in cognitive units)."""
    # Context switch cost
    base_cost = 1.0
    
    # Same category = faster
    if from_tool.category == to_tool.category:
        base_cost *= 0.5
    
    # Target tool complexity
    target_complexity = to_tool.properties.cognitive_load / 10.0
    
    return base_cost + target_complexity


def phase_diversity_bonus(from_tool: Tool, to_tool: Tool) -> float:
    """Bonus for covering different phases."""
    if from_tool.hd4_phase != to_tool.hd4_phase:
        return 1.0
    return 0.0


def stealth_score(tool: Tool) -> float:
    """Calculate stealth score for a tool (higher = stealthier)."""
    return (1.0 - tool.properties.operational_risk) * tool.properties.feedback_clarity


# ═══════════════════════════════════════════════════════════════════════════════
# CHAIN OPTIMIZER
# ═══════════════════════════════════════════════════════════════════════════════

class ChainOptimizer:
    """Optimize tool chains using Hungarian algorithm."""
    
    def __init__(self, constraints: Optional[ChainConstraints] = None):
        self.constraints = constraints or ChainConstraints()
    
    def get_available_tools(self) -> List[Tool]:
        """Get tools available under current constraints."""
        tools = get_tools_by_persona(self.constraints.persona_level)
        
        # Filter forbidden tools
        tools = [t for t in tools if t.id not in self.constraints.forbidden_tools]
        
        return tools
    
    def optimize_chain(
        self, 
        objective: OptimizationObjective = OptimizationObjective.BALANCED,
        seed_tools: Optional[List[str]] = None
    ) -> OptimizedChain:
        """
        Optimize a tool chain for the given objective.
        
        Args:
            objective: Optimization objective
            seed_tools: Optional starting tools
        
        Returns:
            OptimizedChain with optimal sequence
        """
        available = self.get_available_tools()
        
        if len(available) < 2:
            return OptimizedChain(
                tools=available,
                total_entropy=calculate_chain_entropy([t.id for t in available]),
                estimated_success=0.5,
                objective_score=0.0,
                objective=objective,
                phases_covered=[t.hd4_phase for t in available]
            )
        
        if HAS_SCIPY:
            return self._optimize_hungarian(available, objective, seed_tools)
        else:
            return self._optimize_greedy(available, objective, seed_tools)
    
    def _optimize_hungarian(
        self, 
        tools: List[Tool],
        objective: OptimizationObjective,
        seed_tools: Optional[List[str]]
    ) -> OptimizedChain:
        """Use Hungarian algorithm for optimal assignment."""
        n = min(len(tools), self.constraints.max_tools)
        tools = tools[:n]
        
        # Build cost matrix
        cost_matrix = np.zeros((n, n))
        
        for i, tool_from in enumerate(tools):
            for j, tool_to in enumerate(tools):
                if i == j:
                    cost_matrix[i][j] = float('inf')
                    continue
                
                if objective == OptimizationObjective.STEALTH:
                    cost = tool_to.risk * 10 + transition_noise(tool_from, tool_to)
                elif objective == OptimizationObjective.SPEED:
                    cost = tool_to.cognitive + transition_time(tool_from, tool_to)
                elif objective == OptimizationObjective.COVERAGE:
                    cost = -phase_diversity_bonus(tool_from, tool_to)
                else:  # BALANCED
                    cost = (tool_to.risk * 5 + 
                           tool_to.cognitive * 2 +
                           -phase_diversity_bonus(tool_from, tool_to) * 3)
                
                cost_matrix[i][j] = cost
        
        # Handle inf values for scipy
        max_finite = np.max(cost_matrix[np.isfinite(cost_matrix)])
        cost_matrix[~np.isfinite(cost_matrix)] = max_finite * 10
        
        # Solve assignment
        row_ind, col_ind = linear_sum_assignment(cost_matrix)
        
        # Build chain from assignment
        chain = self._build_chain_from_assignment(tools, row_ind, col_ind)
        
        # Ensure required phases
        chain = self._ensure_required_phases(chain, tools)
        
        return self._create_result(chain, objective)
    
    def _optimize_greedy(
        self,
        tools: List[Tool],
        objective: OptimizationObjective,
        seed_tools: Optional[List[str]]
    ) -> OptimizedChain:
        """Greedy optimization fallback when scipy unavailable."""
        chain = []
        remaining = tools.copy()
        
        # Start with best entry point
        if objective == OptimizationObjective.STEALTH:
            remaining.sort(key=lambda t: t.risk)
        elif objective == OptimizationObjective.SPEED:
            remaining.sort(key=lambda t: t.cognitive)
        else:
            remaining.sort(key=lambda t: t.calculate_entropy()[0])
        
        chain.append(remaining.pop(0))
        
        # Greedily add tools
        while remaining and len(chain) < self.constraints.max_tools:
            last = chain[-1]
            
            # Find best next tool
            best_score = float('inf')
            best_idx = 0
            
            for i, tool in enumerate(remaining):
                if objective == OptimizationObjective.STEALTH:
                    score = tool.risk * 10 + transition_noise(last, tool)
                elif objective == OptimizationObjective.SPEED:
                    score = tool.cognitive + transition_time(last, tool)
                elif objective == OptimizationObjective.COVERAGE:
                    score = -phase_diversity_bonus(last, tool)
                else:
                    score = (tool.risk * 5 + tool.cognitive * 2 
                            - phase_diversity_bonus(last, tool) * 3)
                
                if score < best_score:
                    best_score = score
                    best_idx = i
            
            chain.append(remaining.pop(best_idx))
            
            # Check entropy constraint
            if calculate_chain_entropy([t.id for t in chain]) > self.constraints.max_entropy:
                chain.pop()
                break
        
        return self._create_result(chain, objective)
    
    def _build_chain_from_assignment(
        self, 
        tools: List[Tool],
        row_ind: np.ndarray,
        col_ind: np.ndarray
    ) -> List[Tool]:
        """Build ordered chain from Hungarian assignment."""
        # Create adjacency from assignment
        adjacency = {row: col for row, col in zip(row_ind, col_ind)}
        
        # Find starting node (one with no incoming edge)
        has_incoming = set(col_ind)
        starts = [i for i in range(len(tools)) if i not in has_incoming]
        
        if not starts:
            starts = [0]  # Fallback to first
        
        # Build chain by following adjacency
        chain = []
        current = starts[0]
        visited = set()
        
        while current not in visited and len(chain) < len(tools):
            chain.append(tools[current])
            visited.add(current)
            current = adjacency.get(current, -1)
            if current == -1:
                break
        
        return chain
    
    def _ensure_required_phases(
        self, 
        chain: List[Tool],
        available: List[Tool]
    ) -> List[Tool]:
        """Ensure required phases are covered."""
        if not self.constraints.required_phases:
            return chain
        
        covered = {t.hd4_phase for t in chain}
        missing = set(self.constraints.required_phases) - covered
        
        for phase in missing:
            # Find tool for this phase
            for tool in available:
                if tool.hd4_phase == phase and tool not in chain:
                    chain.append(tool)
                    break
        
        return chain
    
    def _create_result(
        self, 
        chain: List[Tool],
        objective: OptimizationObjective
    ) -> OptimizedChain:
        """Create OptimizedChain result."""
        if not chain:
            return OptimizedChain(
                tools=[],
                total_entropy=0,
                estimated_success=0,
                objective_score=0,
                objective=objective,
                phases_covered=[]
            )
        
        total_entropy = calculate_chain_entropy([t.id for t in chain])
        
        # Estimate success based on average risk
        avg_risk = sum(t.risk for t in chain) / len(chain)
        estimated_success = 1.0 - avg_risk
        
        # Calculate objective score
        if objective == OptimizationObjective.STEALTH:
            obj_score = sum(stealth_score(t) for t in chain) / len(chain)
        elif objective == OptimizationObjective.SPEED:
            obj_score = 10.0 / (sum(t.cognitive for t in chain) / len(chain))
        elif objective == OptimizationObjective.COVERAGE:
            phases = len(set(t.hd4_phase for t in chain))
            obj_score = phases / 5.0  # 5 total phases
        else:
            obj_score = estimated_success
        
        return OptimizedChain(
            tools=chain,
            total_entropy=total_entropy,
            estimated_success=estimated_success,
            objective_score=obj_score,
            objective=objective,
            phases_covered=list(set(t.hd4_phase for t in chain))
        )
    
    def compare_objectives(
        self, 
        seed_tools: Optional[List[str]] = None
    ) -> Dict[OptimizationObjective, OptimizedChain]:
        """Compare optimization across all objectives."""
        results = {}
        for objective in OptimizationObjective:
            results[objective] = self.optimize_chain(objective, seed_tools)
        return results
