#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════════════════════════
# SX9 OPS CLI - IDE Bootloader & Mission Control
# ═══════════════════════════════════════════════════════════════════════════════
# Usage:
#   sx9 init                    # Initialize .sx9 in current directory
#   sx9 boot [persona]          # Generate IDE rules with persona
#   sx9 mission new <prompt>    # Start new mission from prompt file
#   sx9 mission status          # Show active missions
#   sx9 mission checkpoint      # Log checkpoint for active mission
#   sx9 mission complete <id>   # Mark mission complete
#   sx9 mission fail <id>       # Mark mission failed
#   sx9 prompt new [type]       # Open Prompt Forge with type preset
#   sx9 prompt list             # List available prompts
#   sx9 log                     # Tail mission logs
# ═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

VERSION="1.0.0"
SX9_DIR=".sx9"
BOOTLOADER="${SX9_DIR}/bootloader.yaml"
MISSIONS_DIR="${SX9_DIR}/missions"
PROMPTS_DIR="${SX9_DIR}/prompts"
LOGS_DIR="${SX9_DIR}/logs"
SCRATCH_DIR="${SX9_DIR}/scratch"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# ═══════════════════════════════════════════════════════════════════════════════
# HELPERS
# ═══════════════════════════════════════════════════════════════════════════════

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

timestamp() { date +"%Y-%m-%d %H:%M:%S"; }
datestamp() { date +"%Y%m%d"; }
mission_id() { echo "MSN-$(datestamp)-$(date +%H%M%S)"; }

check_sx9_dir() {
    if [[ ! -d "$SX9_DIR" ]]; then
        log_error "Not an SX9 project. Run 'sx9 init' first."
        exit 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# INIT - Set up .sx9 directory structure
# ═══════════════════════════════════════════════════════════════════════════════

cmd_init() {
    log_info "Initializing SX9 ops control plane..."
    
    # Create directory structure
    mkdir -p "$MISSIONS_DIR"/{active,completed,failed}
    mkdir -p "$PROMPTS_DIR"
    mkdir -p "$LOGS_DIR"
    mkdir -p "$SCRATCH_DIR"
    mkdir -p "${SX9_DIR}/templates"
    
    # Create bootloader if not exists
    if [[ ! -f "$BOOTLOADER" ]]; then
        cat > "$BOOTLOADER" << 'BOOTLOADER_EOF'
# SX9 Bootloader Configuration
version: "1.0"
project: "synaptix9"

identity:
  default_persona: "FORGE"

constraints:
  hard:
    - "DO NOT modify .env, secrets/, credentials/"
    - "DO NOT push without approval"
    - "DO NOT create files > 300 lines"
    - "DO NOT renumber RFCs"
  soft:
    - "Prefer small scripts over frameworks"
    - "Document all decisions"
    - "Follow existing conventions"

filesystem:
  forbidden:
    - ".env*"
    - "secrets/"
    - "*.pem"
    - "*.key"
  protected:
    - "src/"
    - "01-rfc/"
BOOTLOADER_EOF
        log_success "Created $BOOTLOADER"
    fi
    
    # Create .gitignore for sx9
    cat > "${SX9_DIR}/.gitignore" << 'EOF'
scratch/
*.log
*.tmp
EOF
    
    log_success "SX9 initialized at $(pwd)/${SX9_DIR}"
    log_info "Next: Run 'sx9 boot' to generate IDE rules"
}

# ═══════════════════════════════════════════════════════════════════════════════
# BOOT - Generate IDE rules from bootloader
# ═══════════════════════════════════════════════════════════════════════════════

cmd_boot() {
    check_sx9_dir
    local persona="${1:-FORGE}"
    
    log_info "Generating IDE rules for persona: $persona"
    
    # Generate .cursorrules
    cat > ".cursorrules" << CURSORRULES_EOF
# ═══════════════════════════════════════════════════════════════════════════════
# SX9 CURSOR RULES - Auto-generated by sx9 boot
# Generated: $(timestamp)
# Persona: $persona
# ═══════════════════════════════════════════════════════════════════════════════

## IDENTITY

You are operating within the Synaptix9 (SX9) project as persona: $persona

$(get_persona_role "$persona")

## HARD CONSTRAINTS (VIOLATIONS = IMMEDIATE HALT)

- DO NOT modify files in: .env, secrets/, credentials/, keys/, *.pem, *.key
- DO NOT push to remote repositories without explicit user approval
- DO NOT execute commands against production systems
- DO NOT create files larger than 300 lines - decompose into modules
- DO NOT renumber existing RFCs in 01-rfc/
- DO NOT store secrets, passwords, or API keys in code or logs
- HALT immediately on any credential exposure and report to user

## SOFT CONSTRAINTS (FOLLOW UNLESS JUSTIFIED)

- Prefer small, readable scripts over frameworks
- Document all decisions in *_NOTES.md files
- Follow existing code conventions in the repository
- Include tests for all new functionality
- Commit after each logical, working change
- Keep modules under 200-300 lines

## PROJECT STRUCTURE

\`\`\`
01-rfc/          # RFC documents (add-only, no renumbering)
02-sx9-latex/    # Shared LaTeX system (single system for all)
03-sx9-tools/    # Build scripts (keep under 200 lines each)
04-sx9-research/ # Research notes (cite sources)
05-sx9-converge/ # Change bundles (sequential by date)
.sx9/            # Ops control (prompts, missions, logs)
\`\`\`

## WORKFLOW

1. Before any task: Read the prompt YAML in .sx9/prompts/ if one exists
2. Verify you have required permissions for the task
3. Check for active mission in .sx9/missions/active/
4. Execute task steps sequentially
5. Stop at checkpoints and report status
6. Log all significant actions
7. Verify acceptance criteria before declaring complete

## MISSION CONTROL

- Active missions are in: .sx9/missions/active/
- Log entries go to: .sx9/logs/
- Scratch space is: .sx9/scratch/ (safe to use freely)

When starting work, check for active missions and continue from last checkpoint.
CURSORRULES_EOF

    log_success "Generated .cursorrules"
    
    # Generate VS Code settings
    mkdir -p .vscode
    cat > ".vscode/settings.json" << 'VSCODE_EOF'
{
  "editor.rulers": [100, 300],
  "files.exclude": {
    "**/.sx9/scratch": true,
    "**/.sx9/logs/*.log": true
  },
  "search.exclude": {
    ".sx9/scratch": true
  }
}
VSCODE_EOF
    log_success "Generated .vscode/settings.json"
    
    # Generate VS Code tasks
    cat > ".vscode/tasks.json" << 'TASKS_EOF'
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "SX9: New Mission",
      "type": "shell",
      "command": "sx9 mission new",
      "problemMatcher": []
    },
    {
      "label": "SX9: Mission Status",
      "type": "shell", 
      "command": "sx9 mission status",
      "problemMatcher": []
    },
    {
      "label": "SX9: Checkpoint",
      "type": "shell",
      "command": "sx9 mission checkpoint",
      "problemMatcher": []
    }
  ]
}
TASKS_EOF
    log_success "Generated .vscode/tasks.json"
    
    log_success "IDE boot complete. Persona '$persona' is active."
}

get_persona_role() {
    local persona="$1"
    case "$persona" in
        FORGE)
            echo "You are FORGE, a senior build/infrastructure engineer for SX9."
            echo "You create reliable, reproducible pipelines with minimal dependencies."
            echo "You prefer small, readable scripts over frameworks."
            ;;
        AXIOM)
            echo "You are AXIOM, a systems architect implementing clean, modular code."
            echo "You write concise modules under 300 lines with tests."
            echo "You prefer composition over inheritance."
            ;;
        VECTOR)
            echo "You are VECTOR, a security engineer conducting thorough audits."
            echo "You NEVER modify files during audits - read-only only."
            echo "You flag findings with severity levels."
            ;;
        SENTINEL)
            echo "You are SENTINEL, a threat analyst and red team operator."
            echo "You map actions to MITRE ATT&CK framework."
            echo "You document detection opportunities."
            ;;
        NEXUS)
            echo "You are NEXUS, an integration specialist."
            echo "You always have a rollback plan."
            echo "You validate data integrity at every step."
            ;;
        *)
            echo "You are a senior engineer for SX9."
            echo "You operate with precision and document every decision."
            ;;
    esac
}

# ═══════════════════════════════════════════════════════════════════════════════
# MISSION - Mission lifecycle management
# ═══════════════════════════════════════════════════════════════════════════════

cmd_mission() {
    check_sx9_dir
    local subcmd="${1:-status}"
    shift || true
    
    case "$subcmd" in
        new)
            mission_new "$@"
            ;;
        status)
            mission_status
            ;;
        checkpoint)
            mission_checkpoint "$@"
            ;;
        complete)
            mission_complete "$@"
            ;;
        fail)
            mission_fail "$@"
            ;;
        *)
            log_error "Unknown mission command: $subcmd"
            echo "Usage: sx9 mission {new|status|checkpoint|complete|fail}"
            exit 1
            ;;
    esac
}

mission_new() {
    local prompt_file="${1:-}"
    local id=$(mission_id)
    local mission_file="${MISSIONS_DIR}/active/${id}.yaml"
    
    log_info "Creating new mission: $id"
    
    if [[ -n "$prompt_file" && -f "$prompt_file" ]]; then
        # Copy prompt to mission
        cp "$prompt_file" "$mission_file"
        # Update status
        echo "execution:" >> "$mission_file"
        echo "  status: ACTIVE" >> "$mission_file"
        echo "  started: $(timestamp)" >> "$mission_file"
        echo "  log: []" >> "$mission_file"
    else
        # Create minimal mission
        cat > "$mission_file" << MISSION_EOF
# SX9 Mission
# ID: $id
# Created: $(timestamp)

header:
  id: $id
  title: "[UNTITLED MISSION]"
  created: $(timestamp)

objective: |
  [DEFINE OBJECTIVE]

execution:
  status: ACTIVE
  started: $(timestamp)
  log: []
MISSION_EOF
    fi
    
    # Log mission start
    echo "[$(timestamp)] Mission $id STARTED" >> "${LOGS_DIR}/missions.log"
    
    log_success "Mission created: $mission_file"
    log_info "Edit the mission file to define objectives and constraints"
}

mission_status() {
    log_info "Active Missions:"
    echo ""
    
    local count=0
    for mission in "${MISSIONS_DIR}/active/"*.yaml; do
        if [[ -f "$mission" ]]; then
            local id=$(basename "$mission" .yaml)
            local title=$(grep -m1 "title:" "$mission" | cut -d'"' -f2 || echo "Untitled")
            local status=$(grep -m1 "status:" "$mission" | awk '{print $2}' || echo "UNKNOWN")
            
            echo -e "  ${CYAN}$id${NC}"
            echo -e "    Title:  $title"
            echo -e "    Status: ${GREEN}$status${NC}"
            echo ""
            ((count++)) || true
        fi
    done
    
    if [[ $count -eq 0 ]]; then
        echo "  No active missions."
        echo ""
        log_info "Start a new mission with: sx9 mission new"
    fi
}

mission_checkpoint() {
    local note="${1:-Checkpoint reached}"
    
    # Find most recent active mission
    local latest=$(ls -t "${MISSIONS_DIR}/active/"*.yaml 2>/dev/null | head -1)
    
    if [[ -z "$latest" ]]; then
        log_error "No active mission found"
        exit 1
    fi
    
    local id=$(basename "$latest" .yaml)
    
    # Append checkpoint to log
    echo "  - timestamp: $(timestamp)" >> "$latest"
    echo "    event: CHECKPOINT" >> "$latest"
    echo "    note: \"$note\"" >> "$latest"
    
    # Also log to file
    echo "[$(timestamp)] Mission $id CHECKPOINT: $note" >> "${LOGS_DIR}/missions.log"
    
    log_success "Checkpoint logged for mission $id"
}

mission_complete() {
    local id="${1:-}"
    
    if [[ -z "$id" ]]; then
        # Use most recent
        local latest=$(ls -t "${MISSIONS_DIR}/active/"*.yaml 2>/dev/null | head -1)
        if [[ -n "$latest" ]]; then
            id=$(basename "$latest" .yaml)
        fi
    fi
    
    local mission_file="${MISSIONS_DIR}/active/${id}.yaml"
    
    if [[ ! -f "$mission_file" ]]; then
        log_error "Mission not found: $id"
        exit 1
    fi
    
    # Update status
    sed -i 's/status: ACTIVE/status: COMPLETED/' "$mission_file"
    echo "  completed: $(timestamp)" >> "$mission_file"
    
    # Move to completed
    mv "$mission_file" "${MISSIONS_DIR}/completed/"
    
    # Log
    echo "[$(timestamp)] Mission $id COMPLETED" >> "${LOGS_DIR}/missions.log"
    
    log_success "Mission $id completed"
}

mission_fail() {
    local id="${1:-}"
    local reason="${2:-Unspecified failure}"
    
    if [[ -z "$id" ]]; then
        local latest=$(ls -t "${MISSIONS_DIR}/active/"*.yaml 2>/dev/null | head -1)
        if [[ -n "$latest" ]]; then
            id=$(basename "$latest" .yaml)
        fi
    fi
    
    local mission_file="${MISSIONS_DIR}/active/${id}.yaml"
    
    if [[ ! -f "$mission_file" ]]; then
        log_error "Mission not found: $id"
        exit 1
    fi
    
    # Update status
    sed -i 's/status: ACTIVE/status: FAILED/' "$mission_file"
    echo "  failed: $(timestamp)" >> "$mission_file"
    echo "  failure_reason: \"$reason\"" >> "$mission_file"
    
    # Move to failed
    mv "$mission_file" "${MISSIONS_DIR}/failed/"
    
    # Log
    echo "[$(timestamp)] Mission $id FAILED: $reason" >> "${LOGS_DIR}/missions.log"
    
    log_error "Mission $id failed: $reason"
}

# ═══════════════════════════════════════════════════════════════════════════════
# PROMPT - Prompt management
# ═══════════════════════════════════════════════════════════════════════════════

cmd_prompt() {
    check_sx9_dir
    local subcmd="${1:-list}"
    shift || true
    
    case "$subcmd" in
        new)
            prompt_new "$@"
            ;;
        list)
            prompt_list
            ;;
        load)
            prompt_load "$@"
            ;;
        *)
            log_error "Unknown prompt command: $subcmd"
            exit 1
            ;;
    esac
}

prompt_new() {
    local type="${1:-CUSTOM}"
    local id="PRM-$(datestamp)-$(date +%H%M%S)"
    local prompt_file="${PROMPTS_DIR}/${id}.yaml"
    
    cat > "$prompt_file" << PROMPT_EOF
# SX9-PROMPT v1.0
# Type: $type
# Generated: $(timestamp)
# ═══════════════════════════════════════════════════════════════════════════════

header:
  id: $id
  rfc: N/A
  title: "[TITLE]"
  author: Charles E. Payne
  date: $(date +%Y-%m-%d)
  phase: PLAN
  classification: INTERNAL
  persona: FORGE
  priority: P2

harness:
  agent: CLAUDE
  mode: SUPERVISED
  temperature: 0.2
  timeout: 30m
  on_fail: HALT
  tools: [fs_read, git_read]

  filesystem:
    workdir: "./"
    forbid: [.env, secrets/]

objective: |
  [DEFINE OBJECTIVE]

context: |
  [PROVIDE CONTEXT]

constraints:
  hard:
    - DO NOT modify files outside working directory
  soft:
    - Document all decisions

deliverables:
  - id: D1
    name: "[DELIVERABLE]"

acceptance:
  - All deliverables exist
  - No constraint violations

role: |
  You are a senior engineer for SX9.

task: |
  [DEFINE TASK STEPS]

execution:
  status: DRAFTED
  log: []
PROMPT_EOF

    log_success "Created prompt: $prompt_file"
    
    # Open in editor
    if [[ -n "${EDITOR:-}" ]]; then
        "$EDITOR" "$prompt_file"
    else
        log_info "Edit the prompt at: $prompt_file"
    fi
}

prompt_list() {
    log_info "Available Prompts:"
    echo ""
    
    for prompt in "${PROMPTS_DIR}/"*.yaml; do
        if [[ -f "$prompt" ]]; then
            local id=$(basename "$prompt" .yaml)
            local title=$(grep -m1 "title:" "$prompt" | cut -d'"' -f2 || echo "Untitled")
            local status=$(grep -m1 "status:" "$prompt" | awk '{print $2}' || echo "DRAFTED")
            
            echo -e "  ${CYAN}$id${NC}"
            echo -e "    $title [$status]"
        fi
    done
}

prompt_load() {
    local id="${1:-}"
    
    if [[ -z "$id" ]]; then
        log_error "Specify prompt ID"
        exit 1
    fi
    
    local prompt_file="${PROMPTS_DIR}/${id}.yaml"
    
    if [[ ! -f "$prompt_file" ]]; then
        log_error "Prompt not found: $id"
        exit 1
    fi
    
    # Display prompt for copying into agent
    echo ""
    echo "═══════════════════════════════════════════════════════════════════════════════"
    cat "$prompt_file"
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo ""
    log_info "Copy the above prompt into your agent context"
}

# ═══════════════════════════════════════════════════════════════════════════════
# LOG - View logs
# ═══════════════════════════════════════════════════════════════════════════════

cmd_log() {
    check_sx9_dir
    local lines="${1:-20}"
    
    if [[ -f "${LOGS_DIR}/missions.log" ]]; then
        tail -n "$lines" "${LOGS_DIR}/missions.log"
    else
        log_info "No logs yet"
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════════

cmd_help() {
    cat << 'HELP'
SX9 OPS CLI - IDE Bootloader & Mission Control

Usage: sx9 <command> [options]

Commands:
  init                    Initialize .sx9 in current directory
  boot [persona]          Generate IDE rules (FORGE|AXIOM|VECTOR|SENTINEL|NEXUS)
  
  mission new [prompt]    Start new mission from prompt file
  mission status          Show active missions
  mission checkpoint      Log checkpoint for active mission
  mission complete [id]   Mark mission complete
  mission fail [id]       Mark mission failed
  
  prompt new [type]       Create new prompt YAML
  prompt list             List available prompts
  prompt load <id>        Display prompt for copying
  
  log [lines]             Show recent log entries

Examples:
  sx9 init                          # First time setup
  sx9 boot VECTOR                   # Boot as security engineer
  sx9 mission new .sx9/prompts/PRM-*.yaml  # Start mission from prompt
  sx9 mission checkpoint "Phase 1 complete"

HELP
}

main() {
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        init)
            cmd_init "$@"
            ;;
        boot)
            cmd_boot "$@"
            ;;
        mission)
            cmd_mission "$@"
            ;;
        prompt)
            cmd_prompt "$@"
            ;;
        log)
            cmd_log "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-v)
            echo "sx9 version $VERSION"
            ;;
        *)
            log_error "Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
